Index: libs/picomodel/pm_ase.c
===================================================================
--- libs/picomodel/pm_ase.c	(revision 191)
+++ libs/picomodel/pm_ase.c	(working copy)
@@ -32,6 +32,7 @@
 
 ----------------------------------------------------------------------------- */
 
+void Sys_Printf (const char *format, ...);
 
 /* marker */
 #define PM_ASE_C
@@ -253,7 +254,6 @@
 struct aseVertex_s
 {
 	picoVec3_t xyz;
-	picoVec3_t normal;
 	picoIndex_t id;
 };
 
@@ -276,6 +276,8 @@
 	picoIndex_t smoothingGroup;
 	picoIndex_t materialId;
 	picoIndex_t subMaterialId;
+   picoVec3_t  facenormal;
+   picoVec3_t  vertexnormal[3];
 };
 typedef aseFace_t* aseFacesIter_t;
 
@@ -455,33 +457,157 @@
 
 #endif
 
+static int VectorCompareExtn( picoVec3_t n1, picoVec3_t n2, float epsilon )
+{
+	int		i;
+	
+	
+	/* test */
+	for( i= 0; i < 3; i++ )
+		if( fabs( n1[ i ] - n2[ i ]) > epsilon )
+			return -1;
+	return 1;
+}
+
+#define CrossProductTemp(a,b,c)		((c)[0]=(a)[1]*(b)[2]-(a)[2]*(b)[1],(c)[1]=(a)[2]*(b)[0]-(a)[0]*(b)[2],(c)[2]=(a)[0]*(b)[1]-(a)[1]*(b)[0])
+
 static void _ase_submit_triangles( picoModel_t* model , aseMaterial_t* materials , aseVertex_t* vertices, aseTexCoord_t* texcoords, aseColor_t* colors, aseFace_t* faces, int numFaces )
 {
-	aseFacesIter_t i = faces, end = faces + numFaces;
-	for(; i != end; ++i)
+   
+   picoVec3_t accum;
+   int index;
+   int counter;
+   aseFacesIter_t i = faces, end = faces + numFaces;
+   counter=0;
+
+   //rebuild normals
+   for(i=faces; i != end; ++i)
+   {
+    
+      //&(*i).facenormal
+	   //vec3_t v1, v2;
+	   //VectorSubtract(va, vb, v1);
+	   //VectorSubtract(vc, vb, v2);
+      //CrossProduct(v1, v2, out);
+      
+      picoVec3_t a,b,c;
+      picoVec3_t v1,v2,v3;
+      int j;
+      counter++;
+      for (j=0;j<3;j++)
+      {
+         a[j]    =  vertices[(*i).indices[0]].xyz[j];
+         b[j]    =  vertices[(*i).indices[1]].xyz[j];
+         c[j]    =  vertices[(*i).indices[2]].xyz[j];
+      }
+      for (j=0;j<3;j++)
+      {
+         v1[j]=a[j]-b[j];
+         v2[j]=c[j]-b[j];
+      }
+      
+      CrossProductTemp(v1,v2,v3);
+      _pico_normalize_vec(v3);
+      (*i).facenormal[0]=v3[0];
+      (*i).facenormal[1]=v3[1];
+      (*i).facenormal[2]=v3[2];
+      
+      
+   }
+   
+   
+   //if (counter>0) Sys_Printf( "Rebuilding %d Normals\n", counter * 3 );
+   for(i=faces; i != end; ++i)
 	{
-		/* look up the shader for the material/submaterial pair */
+      /* look up the shader for the material/submaterial pair */
 		aseSubMaterial_t* subMtl = _ase_get_submaterial_or_default( materials, (*i).materialId, (*i).subMaterialId );
-		if( subMtl == NULL )
+
+      if( subMtl == NULL )
 		{
 			return;
 		}
 
 		{
 			picoVec3_t* xyz[3];
+         picoVec3_t *a[3];
 			picoVec3_t* normal[3];
 			picoVec2_t* st[3];
 			picoColor_t* color[3];
 			picoIndex_t smooth[3];
-			int j;
-			/* we pull the data from the vertex, color and texcoord arrays using the face index data */
-			for ( j = 0 ; j < 3 ; j ++ )
+
+			int j,z;
+
+         
+   
+         /* we pull the data from the vertex, color and texcoord arrays using the face index data */
+         for ( j = 0 ; j < 3 ; j ++ )
 			{
-				xyz[j]    = &vertices[(*i).indices[j]].xyz;
-				normal[j] = &vertices[(*i).indices[j]].normal;
+            aseFacesIter_t q = faces;
+            aseFacesIter_t qend = faces + numFaces;
+
+            xyz[j]    = &vertices[(*i).indices[j]].xyz;
+            
+            // Use Face normal
+            normal[j] = &(*i).facenormal;
+             
+     
+            //Oooor we can use the smoothing group
+
+            //Slow method, but testing
+            //Find All faces that use this vertex, average their facenormals.
+            // skip where smoothgroups both equal 0, or don't have any shared bits (x & y)
+            index=(*i).indices[j];
+    
+//            accum[0]=0;
+  //          accum[1]=0;
+    //        accum[2]=0;
+            accum[0]=(*i).facenormal[0];
+            accum[1]=(*i).facenormal[1];
+            accum[2]=(*i).facenormal[2];
+            counter=1;
+           
+            
+            z=0;
+            for(; q != qend; ++q)
+            {
+               z++;
+               if (q==i)
+                  continue;
+               // if  ( (*q).indices[0]==index || (*q).indices[1]==index || (*q).indices[2]==index) 
+                a[0]=  &vertices[(*q).indices[0] ].xyz; 
+                a[1]=  &vertices[(*q).indices[1] ].xyz; 
+                a[2]=  &vertices[(*q).indices[2] ].xyz; 
+               
+               if ( VectorCompareExtn(*a[0],*xyz[j],0.01f)>0 ||
+                    VectorCompareExtn(*a[1],*xyz[j],0.01f)>0 ||
+                    VectorCompareExtn(*a[2],*xyz[j],0.01f)>0
+                  )
+               {
+                  if ( (*i).smoothingGroup==0 && (*q).smoothingGroup ==0 )
+                     continue;
+
+                  if ( (*i).smoothingGroup & (*q).smoothingGroup  )
+                  {
+                     accum[0]+=(*q).facenormal[0];
+                     accum[1]+=(*q).facenormal[1];
+                     accum[2]+=(*q).facenormal[2];
+                     
+                     counter++;
+             
+                  }
+               }
+            } 
+            _pico_normalize_vec(accum); 
+
+            (*i).vertexnormal[j][0]=accum[0];
+            (*i).vertexnormal[j][1]=accum[1];
+            (*i).vertexnormal[j][2]=accum[2];
+            normal[j]=&(*i).vertexnormal[j]; 
+                        
+
 				st[j]     = &texcoords[(*i).indices[j + 3]].texcoord;
-	 	 	
-				if( colors != NULL && (*i).indices[j + 6] >= 0 )
+	 	 	      
+          	if( colors != NULL && (*i).indices[j + 6] >= 0 )
 				{
 					color[j] = &colors[(*i).indices[j + 6]].color;
 				}
@@ -490,30 +616,18 @@
 					color[j] = &white;
 				}
 
-				smooth[j] = (vertices[(*i).indices[j]].id * (1 << 16)) + (*i).smoothingGroup; /* don't merge vertices */
+				smooth[j] = 0;//  (vertices[(*i).indices[j]].id * (1 << 16)) + (*i).smoothingGroup; /* don't merge vertices */
 				
 			}
 
 			/* submit the triangle to the model */
 			PicoAddTriangleToModel ( model , xyz , normal , 1 , st , 1 , color , subMtl->shader, smooth );
 		}
+
 	}
 }
 
-static void shadername_convert(char* shaderName)
-{
-  /* unix-style path separators */
-  char* s = shaderName;
-  for(; *s != '\0'; ++s)
-  {
-    if(*s == '\\')
-    {
-      *s = '/';
-    }
-  }
-}
 
-
 /* _ase_load:
  *  loads a 3dsmax ase model file.
 */
@@ -534,6 +648,9 @@
 	int numColorVertices = 0;
 	int numColorVertexFaces = 0;
 	int vertexId = 0;
+   int currentVertexFace=0;
+   int currentVertexIndex=0;
+   int counter=0;
 
 	aseMaterial_t* materials = NULL;
 
@@ -610,10 +727,11 @@
 		}
 		else if (!_pico_stricmp(p->token,"*mesh_numvertex"))
 		{
-			if (!_pico_parse_int( p, &numVertices) )
+  			if (!_pico_parse_int( p, &numVertices) )
 				_ase_error_return("Missing MESH_NUMVERTEX value");
 
 			vertices = _pico_calloc(numVertices, sizeof(aseVertex_t));
+         currentVertexIndex=0;   
 		}
 		else if (!_pico_stricmp(p->token,"*mesh_numfaces"))
 		{
@@ -621,6 +739,7 @@
 				_ase_error_return("Missing MESH_NUMFACES value");
 
 			faces = _pico_calloc(numFaces, sizeof(aseFace_t));
+
 		}
 		else if (!_pico_stricmp(p->token,"*mesh_numtvertex"))
 		{
@@ -685,7 +804,20 @@
 
 			vertices[index].id = vertexId++;
 		}
-		/* model mesh vertex normal */
+		else if (!_pico_stricmp(p->token,"*mesh_facenormal"))
+		{
+		   //Grab the faceindex for the next vertex normals.
+         if( numVertices == 0 )
+				_ase_error_return("Vertex parse error (facenormals)");
+
+         if (!_pico_parse_int( p,&currentVertexFace ))
+				_ase_error_return("Vertex parse error");
+
+ 			if (!_pico_parse_vec( p,faces[currentVertexFace].facenormal ))
+				_ase_error_return("Vertex parse error");
+
+      }
+      /* model mesh vertex normal */
 		else if (!_pico_stricmp(p->token,"*mesh_vertexnormal"))
 		{
 			int			index;
@@ -696,10 +828,25 @@
 			/* get vertex data (orig: index +y -x +z) */
 			if (!_pico_parse_int( p,&index ))
 				_ase_error_return("Vertex parse error");
-			if (!_pico_parse_vec( p,vertices[index].normal ))
+
+         //^^ Index is 'wrong' in .ase models.  they reference the same vert index with multiple normals..
+         // I've tried, this is a lost cause.  Use the SG's
+         // 
+			/*
+         
+         if (!_pico_parse_vec( p,vertices[counter].normal ))
 				_ase_error_return("Vertex parse error");
+         vertices[counter].faceid=index;
+         counter++;
+         */
 		}
 		/* model mesh face */
+		else if (!_pico_stricmp(p->token,"*mesh_normals"))
+      {
+      //   counter=0; //part of the above vertex normals fix
+      }
+         
+      /* model mesh face */
 		else if (!_pico_stricmp(p->token,"*mesh_face"))
 		{
 			picoIndex_t indexes[3];
@@ -736,8 +883,35 @@
 				}
 				if (!_pico_stricmp (p->token,"*MESH_SMOOTHING" ))
 				{
-					_pico_parse_int ( p , &faces[index].smoothingGroup );
-				}
+               int total=0;
+               char* point;
+               char* start;
+               _pico_parse(p,0);
+
+               point=p->token;
+               start=point;
+               faces[index].smoothingGroup=0;
+              
+               //Super dodgy comma delimited string parse
+               while (*point<'A') 
+               {
+                  if (*point<=32 || *point==',')
+                  {
+                     total=atoi(start);
+                     if (total!=0)
+                     {
+                        faces[index].smoothingGroup+=1<<total;
+                     }
+                     start=point+1;
+                  }
+                  
+                  point++;
+               }
+               
+               
+			      
+               
+            }
 				if (!_pico_stricmp (p->token,"*MESH_MTLID" ))
 				{
 					_pico_parse_int ( p , &faces[index].subMaterialId );
@@ -755,19 +929,19 @@
 			int			index;
 
 			if( numVertices == 0 )
-				_ase_error_return("Texture Vertex parse error");
+				_ase_error_return("Vertex parse error");
 
 			/* get uv vertex index */
-			if (!_pico_parse_int( p,&index ) || index >= numTextureVertices)
-				_ase_error_return("Texture vertex parse error");
+			if (!_pico_parse_int( p,&index ))
+				_ase_error_return("UV vertex parse error");
 
 			/* get uv vertex s */
 			if (!_pico_parse_float( p,&texcoords[index].texcoord[0] ))
-				_ase_error_return("Texture vertex parse error");
+				_ase_error_return("UV vertex parse error");
 
 			/* get uv vertex t */
 			if (!_pico_parse_float( p,&texcoords[index].texcoord[1] ))
-				_ase_error_return("Texture vertex parse error");
+				_ase_error_return("UV vertex parse error");
 			
 			/* ydnar: invert t */
 			texcoords[index].texcoord[ 1 ] = 1.0f - texcoords[index].texcoord[ 1 ];
@@ -831,6 +1005,13 @@
 			
 			/* leave alpha alone since we don't get any data from the ASE format */
 			colors[index].color[3] = 255;
+
+         /* 27 hack, red as alpha */
+         colors[index].color[3]=colors[index].color[0];
+         colors[index].color[0]=255;
+         colors[index].color[1]=255;
+         colors[index].color[2]=255;
+
 		}
 		/* model color face */
 		else if (!_pico_stricmp(p->token,"*mesh_cface"))
@@ -900,7 +1081,6 @@
 				{
 					/* set material name */
 					_pico_first_token( materialName );
-          shadername_convert(materialName);
 					PicoSetShaderName( shader, materialName);
 
 					/* set shader's transparency */
@@ -1085,7 +1265,6 @@
 				}
 
 				/* set material name */
-        shadername_convert(materialName);
 				PicoSetShaderName( shader,materialName );
 
 				/* set shader's transparency */
@@ -1115,8 +1294,18 @@
           char* p = mapname;
 
           /* convert to shader-name format */
-          shadername_convert(mapname);
           {
+            /* unix-style path separators */
+            char* s = mapname;
+            for(; *s != '\0'; ++s)
+            {
+              if(*s == '\\')
+              {
+                *s = '/';
+              }
+            }
+          }
+          {
             /* remove extension */
             char* last_period = strrchr(p, '.');
             if(last_period != NULL)
@@ -1125,14 +1314,32 @@
             }
           }
 
-          /* find shader path */
+          /* find game root */
           for(; *p != '\0'; ++p)
           {
-            if(_pico_strnicmp(p, "models/", 7) == 0 || _pico_strnicmp(p, "textures/", 9) == 0)
+            if(_pico_strnicmp(p, "quake", 5) == 0 || _pico_strnicmp(p, "doom", 4) == 0)
             {
               break;
             }
           }
+          /* root-relative */
+          for(; *p != '\0'; ++p)
+          {
+            if(*p == '/')
+            {
+              ++p;
+              break;
+            }
+          }
+          /* game-relative */
+          for(; *p != '\0'; ++p)
+          {
+            if(*p == '/')
+            {
+              ++p;
+              break;
+            }
+          }
 
           if(*p != '\0')
           {
