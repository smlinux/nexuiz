Index: config.py
===================================================================
--- config.py	(revision 297)
+++ config.py	(working copy)
@@ -236,7 +236,7 @@
 		if ( useZ ):
 			env.Append( LIBS = 'z' )
 
-		env.Append( CFLAGS = baseflags )
+		env.Append( CCFLAGS = baseflags )
 		env.Append( CXXFLAGS = baseflags + [ '-fpermissive', '-fvisibility-inlines-hidden' ] )
 		env.Append( CPPPATH = [ 'include', 'libs' ] )
 		env.Append( CPPDEFINES = [ 'Q_NO_STLPORT' ] )
Index: plugins/surface/surfacedialog.cpp
===================================================================
--- plugins/surface/surfacedialog.cpp	(revision 297)
+++ plugins/surface/surfacedialog.cpp	(working copy)
@@ -1027,7 +1027,7 @@
   gtk_widget_set_sensitive( GTK_WIDGET( vscale_value_spinbutton ), FALSE );
 
   rotate_value_spinbutton_adj = gtk_adjustment_new (0.0, -360.0, 360.0, 1.0, 10.0, 10.0);
-  rotate_value_spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (rotate_value_spinbutton_adj), 1, 0);
+  rotate_value_spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (rotate_value_spinbutton_adj), 1, 4);
   gtk_widget_show (rotate_value_spinbutton);
   gtk_table_attach (GTK_TABLE (table1), rotate_value_spinbutton, 1, 2, 10, 11,
                     (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
@@ -1078,7 +1078,7 @@
   gtk_spin_button_set_wrap (GTK_SPIN_BUTTON (vscale_offset_spinbutton), TRUE);
 
   rotate_offset_spinbutton_adj = gtk_adjustment_new (0.0, -360.0, 360.0, 1.0, 10.0, 10.0);
-  rotate_offset_spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (rotate_offset_spinbutton_adj), 0, 2);
+  rotate_offset_spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (rotate_offset_spinbutton_adj), 0, 4);
   gtk_widget_show (rotate_offset_spinbutton);
   gtk_table_attach (GTK_TABLE (table1), rotate_offset_spinbutton, 2, 3, 10, 11,
                     (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
@@ -1121,7 +1121,7 @@
   gtk_spin_button_set_update_policy (GTK_SPIN_BUTTON (vscale_step_spinbutton), GTK_UPDATE_IF_VALID);
 
   rotate_step_spinbutton_adj = gtk_adjustment_new (0.0, -360.0, 360.0, 1.0, 10.0, 10.0);
-  rotate_step_spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (rotate_step_spinbutton_adj), 1, 2);
+  rotate_step_spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (rotate_step_spinbutton_adj), 1, 4);
   gtk_widget_show (rotate_step_spinbutton);
   gtk_table_attach (GTK_TABLE (table1), rotate_step_spinbutton, 3, 4, 10, 11,
                     (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
Index: radiant/preferences.h
===================================================================
--- radiant/preferences.h	(revision 297)
+++ radiant/preferences.h	(working copy)
@@ -579,6 +579,7 @@
   bool  m_bPluginToolbar;
   bool  m_bNoClamp;
 	//++timo this is most likely broken, I don't know what it's supposed to do
+  bool  m_bSnap;
   Str   m_strUserPath;
   int   m_nRotation;
   bool  m_bChaseMouse;
Index: radiant/mainframe.cpp
===================================================================
--- radiant/mainframe.cpp	(revision 297)
+++ radiant/mainframe.cpp	(working copy)
@@ -3824,7 +3824,7 @@
   item  = GTK_WIDGET (g_object_get_data (G_OBJECT (m_pWidget), "menu_view_opengllighting"));
   gtk_check_menu_item_set_active (GTK_CHECK_MENU_ITEM (item), (g_PrefsDlg.m_bGLLighting) ? TRUE : FALSE);
   item  = GTK_WIDGET (g_object_get_data (G_OBJECT (m_pWidget), "menu_snaptogrid"));
-  gtk_check_menu_item_set_active (GTK_CHECK_MENU_ITEM (item), (!g_PrefsDlg.m_bNoClamp) ? TRUE : FALSE);
+  gtk_check_menu_item_set_active (GTK_CHECK_MENU_ITEM (item), (g_PrefsDlg.m_bSnap) ? TRUE : FALSE);
 
   item = GTK_WIDGET (g_object_get_data (G_OBJECT (m_pWidget), "tb_view_cubicclipping"));
   gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (item), (g_PrefsDlg.m_bCubicClipping) ? TRUE : FALSE);
@@ -4658,7 +4658,7 @@
     GtkWidget *item = GTK_WIDGET (g_object_get_data (G_OBJECT (m_pWidget), "menu_snaptogrid"));
     g_bIgnoreCommands++;
     gtk_check_menu_item_set_active (GTK_CHECK_MENU_ITEM (item),
-                                    (!g_PrefsDlg.m_bNoClamp) ? TRUE : FALSE);
+                                    (g_PrefsDlg.m_bSnap) ? TRUE : FALSE);
     g_bIgnoreCommands--;
   }
 }
@@ -5686,12 +5686,12 @@
 
 void MainFrame::OnSnaptogrid()
 {
-  g_PrefsDlg.m_bNoClamp ^= 1;
+  g_PrefsDlg.m_bSnap ^= 1;
   g_PrefsDlg.SavePrefs ();
 
   GtkWidget *item = GTK_WIDGET (g_object_get_data (G_OBJECT (m_pWidget), "menu_snaptogrid"));
   g_bIgnoreCommands++;
-  gtk_check_menu_item_set_active (GTK_CHECK_MENU_ITEM (item), g_PrefsDlg.m_bNoClamp ? FALSE : TRUE);
+  gtk_check_menu_item_set_active (GTK_CHECK_MENU_ITEM (item), g_PrefsDlg.m_bSnap ? TRUE : FALSE);
   g_bIgnoreCommands--;
 }
 
Index: radiant/preferences.cpp
===================================================================
--- radiant/preferences.cpp	(revision 297)
+++ radiant/preferences.cpp	(working copy)
@@ -96,6 +96,7 @@
 #define WIDETOOLBAR_KEY         "WideToolBar"
 #define PLUGINTOOLBAR_KEY "PluginToolBar"
 #define NOCLAMP_KEY             "NoClamp"
+#define SNAP_KEY                "Snap"
 #define PREFAB_KEY              "PrefabPath"
 #define USERINI_KEY             "UserINIPath"
 #define ROTATION_KEY            "Rotation"
@@ -635,6 +636,7 @@
   m_bWideToolbar = TRUE;
   m_bPluginToolbar = TRUE;
   m_bNoClamp = FALSE;
+  m_bSnap = TRUE;
   m_strUserPath = "";
   m_nRotation = 0;
   m_bChaseMouse = FALSE;
@@ -2342,6 +2344,12 @@
   gtk_box_pack_start(GTK_BOX(vbox), check, FALSE, FALSE, 0);
   AddDialogData (check, &m_bNoClamp, DLG_CHECK_BOOL);
 
+  // Snap to grid
+  check = gtk_check_button_new_with_label (_("Snap to grid"));
+  gtk_widget_show (check);
+  gtk_box_pack_start(GTK_BOX(vbox), check, FALSE, FALSE, 0);
+  AddDialogData (check, &m_bSnap, DLG_CHECK_BOOL);
+
   // Select patch by bounding box
   check = gtk_check_button_new_with_label (_("Select patches by bounding box"));
   gtk_widget_show (check);
@@ -2912,6 +2920,7 @@
   m_nShader = m_nLatchedShader;
 
   mLocalPrefs.GetPref(NOCLAMP_KEY,            &m_bNoClamp,                    FALSE);
+  mLocalPrefs.GetPref(SNAP_KEY,               &m_bSnap,                       TRUE);
   mLocalPrefs.GetPref(USERINI_KEY,            &m_strUserPath,                 "");
   mLocalPrefs.GetPref(ROTATION_KEY,           &m_nRotation,                   45);
   mLocalPrefs.GetPref(CHASEMOUSE_KEY,         &m_bChaseMouse,                 TRUE);
Index: radiant/surfaceplugin.cpp
===================================================================
--- radiant/surfaceplugin.cpp	(revision 297)
+++ radiant/surfaceplugin.cpp	(working copy)
@@ -73,6 +73,7 @@
   face_t	*f;
   brush_t	*b;
   texdef_to_face_t *position, *prev_pos;
+  brushprimit_texdef_t bp;
 
   if(selected_brushes.next != &selected_brushes)
   {
@@ -85,8 +86,14 @@
         {
             position->face = f;
             position->brush = b;
-            position->texdef = f->texdef;
-            position->orig_texdef = f->texdef;
+			position->texdef = f->texdef;
+			if(g_qeglobals.m_bBrushPrimitMode)
+			{
+				ConvertTexMatWithQTexture(&f->brushprimit_texdef, QERApp_Shader_ForName( f->texdef.GetName() )->getTexture(), &bp, NULL);
+				TexMatToFakeTexCoords(bp.coords, position->texdef.shift, &position->texdef.rotate, position->texdef.scale);
+				position->orig_bp_texdef = bp;
+			}
+			position->orig_texdef = position->texdef;
             prev_pos->next = position;
             prev_pos = position;
             position++;
@@ -103,7 +110,13 @@
     position->face = f;
     position->brush = b;
     position->texdef = f->texdef;
-    position->orig_texdef = f->texdef;
+	if(g_qeglobals.m_bBrushPrimitMode)
+	{
+		ConvertTexMatWithQTexture(&f->brushprimit_texdef, QERApp_Shader_ForName( f->texdef.GetName() )->getTexture(), &bp, NULL);
+		TexMatToFakeTexCoords(bp.coords, position->texdef.shift, &position->texdef.rotate, position->texdef.scale);
+		position->orig_bp_texdef = bp;
+	}
+    position->orig_texdef = position->texdef;
     prev_pos = position;
     for(i=1; i<g_ptrSelectedFaces.GetSize(); i++)
     {
@@ -113,7 +126,13 @@
       position->face = f;
       position->brush = b;
       position->texdef = f->texdef;
-      position->orig_texdef = f->texdef;
+	  if(g_qeglobals.m_bBrushPrimitMode)
+	  {
+		  ConvertTexMatWithQTexture(&f->brushprimit_texdef, QERApp_Shader_ForName( f->texdef.GetName() )->getTexture(), &bp, NULL);
+		  TexMatToFakeTexCoords(bp.coords, position->texdef.shift, &position->texdef.rotate, position->texdef.scale);
+		  position->orig_bp_texdef = bp;
+	  }
+      position->orig_texdef = position->texdef;
       prev_pos->next = position;
       prev_pos = position;
     }
@@ -187,7 +206,7 @@
       if (b_isQuake2)
         SetFaceTexdef_Q2(texdef_to_face->face, &texdef_to_face->orig_texdef, bFit_to_Scale);
       else
-        SetFaceTexdef(texdef_to_face->face, &texdef_to_face->orig_texdef, NULL);
+        SetFaceTexdef(texdef_to_face->face, &texdef_to_face->orig_texdef, &texdef_to_face->orig_bp_texdef, bFit_to_Scale);
 
       Undo_Start("set facelist texdefs");
 
@@ -204,7 +223,11 @@
     if (b_isQuake2)
       SetFaceTexdef_Q2(texdef_to_face->face, &texdef_to_face->texdef,  bFit_to_Scale);
     else
-      SetFaceTexdef(texdef_to_face->face, &texdef_to_face->texdef, NULL , bFit_to_Scale);
+	{
+	  brushprimit_texdef_t brushprimit_texdef;
+	  FakeTexCoordsToTexMat(texdef_to_face->texdef.shift, texdef_to_face->texdef.rotate, texdef_to_face->texdef.scale, brushprimit_texdef.coords);
+      SetFaceTexdef(texdef_to_face->face, &texdef_to_face->texdef, &brushprimit_texdef , bFit_to_Scale);
+	}
     Brush_Build(texdef_to_face->brush);
     if(bFit_to_Scale)
       texdef_to_face->texdef = texdef_to_face->face->texdef;
@@ -222,7 +245,10 @@
         Undo_End();
 	// Over-write the orig_texdef list, cementing the change.
 	for(texdef_to_face = texdef_face_list; texdef_to_face; texdef_to_face = texdef_to_face->next)
+	{
 	  texdef_to_face->orig_texdef = texdef_to_face->texdef;
+	  texdef_to_face->orig_bp_texdef = texdef_to_face->face->brushprimit_texdef;
+	}
       }
   }
 
@@ -232,6 +258,7 @@
 void SI_FaceList_FitTexture(texdef_to_face_t* si_texdef_face_list, int nHeight, int nWidth)
 {
   texdef_to_face_t* temp_texdef_face_list;
+  brushprimit_texdef_t bp;
 
   if (!si_texdef_face_list)
     return;
@@ -241,6 +268,12 @@
     Face_FitTexture(temp_texdef_face_list->face, nHeight, nWidth);
     Brush_Build(temp_texdef_face_list->brush,true,true,false,false);
     // Write changes to our working Texdef list
+	
+	if(g_qeglobals.m_bBrushPrimitMode)
+	{
+		ConvertTexMatWithQTexture(&temp_texdef_face_list->face->brushprimit_texdef, QERApp_Shader_ForName( temp_texdef_face_list->face->texdef.GetName() )->getTexture(), &bp, NULL);
+		TexMatToFakeTexCoords(bp.coords, temp_texdef_face_list->face->texdef.shift, &temp_texdef_face_list->face->texdef.rotate, temp_texdef_face_list->face->texdef.scale);
+	}
     temp_texdef_face_list->texdef = temp_texdef_face_list->face->texdef;
   }
 
Index: radiant/drag.cpp
===================================================================
--- radiant/drag.cpp	(revision 297)
+++ radiant/drag.cpp	(working copy)
@@ -770,7 +770,7 @@
 		for (i=0 ; i<3 ; i++)
 		{
 			move[i] = drag_xvec[i]*(x - pressx)	+ drag_yvec[i]*(y - pressy);
-			if (!g_PrefsDlg.m_bNoClamp)
+			if (g_PrefsDlg.m_bSnap)
 			{
 				move[i] = floor(move[i]/g_qeglobals.d_gridsize+0.5)*g_qeglobals.d_gridsize;
 			}
Index: radiant/xywindow.cpp
===================================================================
--- radiant/xywindow.cpp	(revision 297)
+++ radiant/xywindow.cpp	(working copy)
@@ -1501,7 +1501,7 @@
   for (i=0 ; i<3 ; i++)
   {
     delta[i] = xvec[i] * (x - m_nPressx) + yvec[i] * (y - m_nPressy);
-    if (!g_PrefsDlg.m_bNoClamp)
+    if (g_PrefsDlg.m_bSnap)
     {
       delta[i] = floor(delta[i] / g_qeglobals.d_gridsize + 0.5) * g_qeglobals.d_gridsize;
     }
@@ -2135,13 +2135,13 @@
 
 void XYWnd::SnapToPoint (int x, int y, vec3_t point)
 {
-  if (g_PrefsDlg.m_bNoClamp)
+  if (g_PrefsDlg.m_bSnap)
   {
-    XY_ToPoint(x, y, point);
+    XY_ToGridPoint(x, y, point);
   }
   else
   {
-    XY_ToGridPoint(x, y, point);
+    XY_ToPoint(x, y, point);
   }
 }
 
Index: radiant/brush_primit.cpp
===================================================================
--- radiant/brush_primit.cpp	(revision 297)
+++ radiant/brush_primit.cpp	(working copy)
@@ -186,11 +186,11 @@
 {
 #ifdef DBG_BP
 	// check this matrix is orthogonal
-	if (fabs(texMat[0][0]*texMat[0][1]+texMat[1][0]*texMat[1][1])>ZERO_EPSILON)
+	if (fabs(texMat[0][0]*1.0L*texMat[0][1]+texMat[1][0]*1.0L*texMat[1][1])>ZERO_EPSILON)
 		Sys_Printf("Warning : non orthogonal texture matrix in TexMatToFakeTexCoords\n");
 #endif
-	scale[0]=sqrt(texMat[0][0]*texMat[0][0]+texMat[1][0]*texMat[1][0]);
-	scale[1]=sqrt(texMat[0][1]*texMat[0][1]+texMat[1][1]*texMat[1][1]);
+	scale[0]=sqrt(texMat[0][0]*1.0L*texMat[0][0]+texMat[1][0]*1.0L*texMat[1][0]);
+	scale[1]=sqrt(texMat[0][1]*1.0L*texMat[0][1]+texMat[1][1]*1.0L*texMat[1][1]);
 #ifdef DBG_BP
 	if (scale[0]<ZERO_EPSILON || scale[1]<ZERO_EPSILON)
 		Sys_Printf("Warning : unexpected scale==0 in TexMatToFakeTexCoords\n");
@@ -210,7 +210,7 @@
 			*rot=-90.0f;
 	}
 	else
-	*rot = RAD2DEG( atan2( texMat[1][0], texMat[0][0] ) );
+	*rot = RAD2DEG( atan2( texMat[1][0]*1.0L, texMat[0][0]*1.0L ) );
 	shift[0] = -texMat[0][2];
 	shift[1] = texMat[1][2];
 }
@@ -219,10 +219,10 @@
 // the matrix returned must be understood as a qtexture_t with width=2 height=2 ( the default one )
 void FakeTexCoordsToTexMat( float shift[2], float rot, float scale[2], vec_t texMat[2][3] )
 {
-	texMat[0][0] = scale[0] * cos( DEG2RAD( rot ) );
-	texMat[1][0] = scale[0] * sin( DEG2RAD( rot ) );
-	texMat[0][1] = -1.0f * scale[1] * sin( DEG2RAD( rot ) );
-	texMat[1][1] = scale[1] * cos( DEG2RAD( rot ) );
+	texMat[0][0] = scale[0] *1.0L* cos( DEG2RAD( 1.0L*rot ) );
+	texMat[1][0] = scale[0] *1.0L* sin( DEG2RAD( 1.0L*rot ) );
+	texMat[0][1] = -scale[1] *1.0L* sin( DEG2RAD( 1.0L*rot ) );
+	texMat[1][1] = scale[1] *1.0L* cos( DEG2RAD( 1.0L*rot ) );
 	texMat[0][2] = -shift[0];
 	texMat[1][2] = shift[1];
 }
Index: radiant/select.cpp
===================================================================
--- radiant/select.cpp	(revision 297)
+++ radiant/select.cpp	(working copy)
@@ -735,7 +735,7 @@
 	vec3_t	mins, maxs;
 	int		i;
 
-  if (g_PrefsDlg.m_bNoClamp)
+  if (!g_PrefsDlg.m_bSnap)
   {
     Select_GetTrueMid(mid);
     return;
Index: include/isurfaceplugin.h
===================================================================
--- include/isurfaceplugin.h	(revision 297)
+++ include/isurfaceplugin.h	(working copy)
@@ -62,6 +62,7 @@
   face_t *face;     // Face of Texdef
   texdef_t texdef;  // Working texdef
   texdef_t orig_texdef;  // Original, for baselining changes
+  brushprimit_texdef_t orig_bp_texdef; // Original, for undo
 };
 
 
