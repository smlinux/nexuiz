Index: radiant/map.cpp
===================================================================
--- radiant/map.cpp	(revision 304)
+++ radiant/map.cpp	(working copy)
@@ -270,6 +270,100 @@
   ents->RemoveAll();
 }
 
+void Map_DoTargetFix(entity_t *e, const char *target, int num_ents, CPtrArray *ents, GPtrArray *new_ents)
+{
+	int j;
+	int id;
+	char newtarget[128];
+	entity_t *e_target;
+
+	qboolean targetnameFound = FALSE;
+	qboolean targetFound = FALSE;
+	qboolean colliding = FALSE;
+
+	if(!target)
+		return;
+	if(!*target)
+		return;
+
+	target = g_strdup(target);
+
+	// check the current map entities for an actual collision
+	for (e_target = entities.next; e_target != &entities; e_target = e_target->next)
+	{
+		if(
+			!strcmp(target, ValueForKey(e_target, "target"))
+			||
+			!strcmp(target, ValueForKey(e_target, "killtarget"))
+		)
+		{
+			// make sure the collision is not between two imported entities
+			for(j=0; j<(int)new_ents->len; j++)
+			{
+				if(e_target == g_ptr_array_index(new_ents, j))
+				{
+					targetFound = true;
+					goto no_collision_yet_1;
+				}
+			}
+			colliding = TRUE;
+no_collision_yet_1:
+			;
+		}
+		if(
+			!strcmp(target, ValueForKey(e_target, "targetname"))
+		)
+		{
+			// make sure the collision is not between two imported entities
+			for(j=0; j<(int)new_ents->len; j++)
+			{
+				if(e_target == g_ptr_array_index(new_ents, j))
+				{
+					targetnameFound = true;
+					goto no_collision_yet_2;
+				}
+			}
+			colliding = TRUE;
+no_collision_yet_2:
+			;
+		}
+	}
+
+	// find the matching targeted entity(s)
+	if(colliding && targetFound && targetnameFound)
+	{
+		// We got a collision
+		// first look for a non-conflicting target name
+		id = GetUniqueTargetId(1);
+		sprintf(newtarget, "t%i", id);
+
+		for(j=num_ents-1; j>0; j--)
+		{
+			e_target = (entity_t*)ents->GetAt(j);
+			if(e_target != NULL)
+			{
+				const char *targetname = ValueForKey(e_target, "targetname");
+				if( (targetname != NULL) && (strcmp(target, targetname) == 0) ) 
+				{
+					SetKeyValue(e_target, "targetname", newtarget);
+				}
+				targetname = ValueForKey(e_target, "target");
+				if( (targetname != NULL) && (strcmp(target, targetname) == 0) )
+				{
+					SetKeyValue(e_target, "target", newtarget);
+				}
+				targetname = ValueForKey(e_target, "killtarget");
+				if( (targetname != NULL) && (strcmp(target, targetname) == 0) )
+				{
+					SetKeyValue(e_target, "killtarget", newtarget);
+				}
+			}
+		}
+	}
+
+	g_free(target);
+}
+
 /*!\todo Possibly make the import Undo-friendly by calling Undo_End for new brushes and ents */
 void Map_ImportEntities(CPtrArray *ents, bool bAddSelected = false)
 {
@@ -466,60 +560,27 @@
     }
     else
     {
-      // fix target/targetname collisions
-      if ((g_PrefsDlg.m_bDoTargetFix) && (strcmp(ValueForKey(e, "target"), "") != 0))
-      {
-        GPtrArray *t_ents = g_ptr_array_new();
-        entity_t *e_target;
-        const char *target = ValueForKey(e, "target");
-        qboolean bCollision=FALSE;
+      // keep a list of ents added to avoid testing collisions against them
+      g_ptr_array_add(new_ents, (gpointer)e);
 
-        // check the current map entities for an actual collision
-        for (e_target = entities.next; e_target != &entities; e_target = e_target->next)
-        {
-          if(!strcmp(target, ValueForKey(e_target, "target")))
-          {
-            bCollision = TRUE;
-            // make sure the collision is not between two imported entities
-            for(j=0; j<(int)new_ents->len; j++)
-            {
-              if(e_target == g_ptr_array_index(new_ents, j))
-                bCollision = FALSE;
-            }
-          }
-        }
-
-        // find the matching targeted entity(s)
-        if(bCollision)
-        {
-          for(j=num_ents-1; j>0; j--)
-          {
-            e_target = (entity_t*)ents->GetAt(j);
-            if(e_target != NULL && e_target != e)
-            {
-              const char *targetname = ValueForKey(e_target, "targetname");
-              if( (targetname != NULL) && (strcmp(target, targetname) == 0) )
-                g_ptr_array_add(t_ents, (gpointer)e_target);
-            }
-          }
-          if(t_ents->len > 0)
-          {
-            // link the first to get a unique target/targetname
-            Entity_Connect(e, (entity_t*)g_ptr_array_index(t_ents,0));
-            // set the targetname of the rest of them manually
-            for(j = 1; j < (int)t_ents->len; j++)
-              SetKeyValue( (entity_t*)g_ptr_array_index(t_ents, j), "targetname", ValueForKey(e, "target") );
-          }
-          g_ptr_array_free(t_ents, FALSE);
-        }
-      }
-
       // add the entity to the end of the entity list
       Entity_AddToList(e, &entities);
       g_qeglobals.d_num_entities++;
 
-      // keep a list of ents added to avoid testing collisions against them
-      g_ptr_array_add(new_ents, (gpointer)e);
+      // fix target/targetname collisions
+      if (g_PrefsDlg.m_bDoTargetFix)
+	  {
+		  const char *target;
+
+		  target = ValueForKey(e, "target");
+		  Map_DoTargetFix(e, target, num_ents, ents, new_ents);
+
+		  target = ValueForKey(e, "killtarget");
+		  Map_DoTargetFix(e, target, num_ents, ents, new_ents);
+
+		  target = ValueForKey(e, "targetname");
+		  Map_DoTargetFix(e, target, num_ents, ents, new_ents);
+	  }
     }
   }
   g_ptr_array_free(new_ents, FALSE);
Index: radiant/drag.cpp
===================================================================
--- radiant/drag.cpp	(revision 304)
+++ radiant/drag.cpp	(working copy)
@@ -255,54 +255,6 @@
 
 entity_t *peLink;
 
-void UpdateTarget(vec3_t origin, vec3_t dir)
-{
-	trace_t	t;
-	entity_t *pe;
-	int i;
-	char sz[128];
-
-	t = Test_Ray (origin, dir, 0);
-
-	if (!t.brush)
-		return;
-
-	pe = t.brush->owner;
-
-	if (pe == NULL)
-		return;
-
-	// is this the first?
-	if (peLink != NULL)
-	{
-
-		// Get the target id from out current target
-		// if there is no id, make one
-
-		i = IntForKey(pe, "target");
-		if (i <= 0)
-		{
-			i = GetUniqueTargetId(1);
-			sprintf(sz, "%d", i);
-
-			SetKeyValue(pe, "target", sz);
-		}
-
-		// set the target # into our src
-
-		sprintf(sz, "%d", i);
-		SetKeyValue(peLink, "targetname", sz);
-
-		Sys_UpdateWindows(W_ENTITY);
-
-	}
-
-	// promote the target to the src
-
-	peLink = pe;
-
-}
-
 /*
 ===========
 Drag_Begin
Index: radiant/xywindow.cpp
===================================================================
--- radiant/xywindow.cpp	(revision 304)
+++ radiant/xywindow.cpp	(working copy)
@@ -270,16 +270,17 @@
 void DrawPathLines (void)
 {
   int       i, j, k;
-  vec3_t    mid, mid1;
+  vec3_t    mid, mid1, v;
   entity_t *se, *te;
   brush_t   *sb, *tb;
   const char    *psz;
-  vec3_t    dir, s1, s2;
+  vec3_t    dir, s1, s2, dirortho;
   vec_t len, f;
   int       arrows;
   int           num_entities;
   const char        *ent_target[MAX_MAP_ENTITIES];
   entity_t  *ent_entity[MAX_MAP_ENTITIES];
+  int lines;
 
   if (g_qeglobals.d_savedinfo.exclude & EXCLUDE_PATHS)
   {
@@ -295,6 +296,12 @@
       ent_entity[num_entities] = te;
       num_entities++;
     }
+    ent_target[num_entities] = ValueForKey (te, "killtarget");
+    if (ent_target[num_entities][0])
+    {
+      ent_entity[num_entities] = te;
+      num_entities++;
+    }
   }
 
   for (se = entities.next ; se != &entities ; se = se->next)
@@ -308,6 +315,9 @@
     if (sb == &se->brushes)
       continue;
 
+	for (i=0 ; i<3 ; i++)
+		mid[i] = (sb->mins[i] + sb->maxs[i])*0.5;
+
     for (k=0 ; k<num_entities ; k++)
     {
       if (strcmp (ent_target[k], psz))
@@ -318,14 +328,20 @@
       if (tb == &te->brushes)
         continue;
 
-      for (i=0 ; i<3 ; i++)
-        mid[i] = (sb->mins[i] + sb->maxs[i])*0.5;
+	  lines = 0;
+	  if(!strcmp(ValueForKey(te, "target"), psz))
+		  lines += 1;
+	  if(!strcmp(ValueForKey(te, "killtarget"), psz))
+		  lines += 2;
 
       for (i=0 ; i<3 ; i++)
         mid1[i] = (tb->mins[i] + tb->maxs[i])*0.5;
 
       VectorSubtract (mid1, mid, dir);
       len = VectorNormalize (dir, dir);
+	  dirortho[0] = -dir[1];
+	  dirortho[1] = dir[0];
+	  dirortho[2] = 0;
       s1[0] = -dir[1]*8 + dir[0]*8;
       s2[0] = dir[1]*8 + dir[0]*8;
       s1[1] = dir[0]*8 + dir[1]*8;
@@ -334,8 +350,13 @@
       qglColor3f (se->eclass->color[0], se->eclass->color[1], se->eclass->color[2]);
 
       qglBegin(GL_LINES);
-      qglVertex3fv(mid);
-      qglVertex3fv(mid1);
+	  for(i = -lines + 1; i < lines; i += 2)
+	  {
+		  VectorMA(mid, i, dirortho, v);
+		  qglVertex3fv(v);
+		  VectorMA(mid1, i, dirortho, v);
+		  qglVertex3fv(v);
+	  }
 
       arrows = (int)(len / 256) + 1;
 
Index: radiant/targetname.cpp
===================================================================
--- radiant/targetname.cpp	(revision 304)
+++ radiant/targetname.cpp	(working copy)
@@ -24,11 +24,11 @@
 /*!
 connects two entities creating a unique target/targetname value 
 */
-void Entity_Connect(entity_t *e1, entity_t *e2)
+void Entity_Connect(entity_t *e1, entity_t *e2, bool kill)
 {
   const char *maptarget;
   char newtarget[16];
-  int maxtarget=0;  // highest t# value in the map
+  int id=0;  // highest t# value in the map
   entity_t *e;      // map entities
 
   if (e1 == e2)
@@ -39,47 +39,54 @@
 		return;
 	}
 
-  for (e=entities.next ; e != &entities ; e=e->next)
-  {
-    maptarget = ValueForKey (e, "target");
-    if (maptarget && maptarget[0])
-    {
-      int targetnum = atoi(maptarget+1);
-      if (targetnum > maxtarget)
-        maxtarget = targetnum;
-    }
-  }
-  sprintf (newtarget, "t%i", maxtarget+1);
+	id = GetUniqueTargetId(1);
+	sprintf (newtarget, "t%i", id);
   
 #ifdef _DEBUG
   Sys_Printf("Connecting entities with new target/targetname: %s\n", newtarget);
 #endif  
   
-	SetKeyValue (e1, "target", newtarget);
+  	if(kill)
+		SetKeyValue (e1, "killtarget", newtarget);
+	else
+		SetKeyValue (e1, "target", newtarget);
 	SetKeyValue (e2, "targetname", newtarget);
 }
 
+static int TargetIdForKey(entity_t *pe, const char *key)
+{
+	const char *p = ValueForKey(pe, key);
+	if(!p)
+		return 0;
+	if(!*p)
+		return 0;
+	return atoi(p + 1);
+}
+
 int GetUniqueTargetId(int iHint)
 {
-	int iMin, iMax, i;
+	int iMax, i;
 	bool fFound;
 	entity_t *pe;
 	
 	fFound = FALSE;
 	pe = entities.next;
-	iMin = 0; 
 	iMax = 0;
 	
 	for (; pe != NULL && pe != &entities ; pe = pe->next)
 	{
-		i = IntForKey(pe, "target");
-		if (i)
-		{
-			iMin = MIN(i, iMin);
-			iMax = MAX(i, iMax);
-			if (i == iHint)
-				fFound = TRUE;
-		}
+		i = TargetIdForKey(pe, "target");
+		iMax = MAX(i, iMax);
+		if (i == iHint)
+			fFound = TRUE;
+		i = TargetIdForKey(pe, "targetname");
+		iMax = MAX(i, iMax);
+		if (i == iHint)
+			fFound = TRUE;
+		i = TargetIdForKey(pe, "killtarget");
+		iMax = MAX(i, iMax);
+		if (i == iHint)
+			fFound = TRUE;
 	}
 
 	if (fFound)
Index: radiant/qe3.cpp
===================================================================
--- radiant/qe3.cpp	(revision 304)
+++ radiant/qe3.cpp	(working copy)
@@ -704,7 +704,7 @@
 from the first selected to the secon
 ===============
 */
-void ConnectEntities (void)
+void ConnectEntities (bool kill)
 {
 	entity_t	*e1, *e2;
 	const char		*target;
@@ -734,7 +734,7 @@
 		return;
 	}
 
-  target = ValueForKey (e1, "target");
+  target = ValueForKey (e1, kill ? "killtarget" : "target");
   if (target && target[0])
     newtarg = g_strdup(target);
   else
@@ -743,12 +743,12 @@
     if(target && target[0])
       newtarg = g_strdup(target);
     else
-      Entity_Connect(e1, e2);
+      Entity_Connect(e1, e2, kill);
   }
 
   if(newtarg != NULL)
   {
-    SetKeyValue(e1, "target", newtarg);
+    SetKeyValue(e1, kill ? "killtarget" : "target", newtarg);
     SetKeyValue(e2, "targetname", newtarg);
     g_free(newtarg);
   }
Index: radiant/qe3.h
===================================================================
--- radiant/qe3.h	(revision 304)
+++ radiant/qe3.h	(working copy)
@@ -229,7 +229,7 @@
 void SelectEdgeByRay (vec3_t org, vec3_t dir);
 void SelectVertexByRay (vec3_t org, vec3_t dir);
 
-void ConnectEntities (void);
+void ConnectEntities (bool kill = false);
 
 extern	int	update_bits;
 
@@ -878,7 +878,7 @@
 
 // SPoG
 // targetname.cpp
-void Entity_Connect(entity_t *e1, entity_t *e2);
+void Entity_Connect(entity_t *e1, entity_t *e2, bool kill = false);
 int GetUniqueTargetId(int iHint);
 
 // xywindow.cpp
