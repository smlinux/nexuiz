Index: tools/quake3/q3map2/convert_map.c
===================================================================
--- tools/quake3/q3map2/convert_map.c.orig	2008-09-06 15:32:05.000000000 +0200
+++ tools/quake3/q3map2/convert_map.c	2008-09-06 15:32:11.000000000 +0200
@@ -46,6 +46,105 @@
 #define	SNAP_FLOAT_TO_INT	4
 #define	SNAP_INT_TO_FLOAT	(1.0 / SNAP_FLOAT_TO_INT)
 
+typedef vec_t vec2_t[2];
+
+static vec_t Det3x3(vec_t a00, vec_t a01, vec_t a02,
+                    vec_t a10, vec_t a11, vec_t a12,
+                    vec_t a20, vec_t a21, vec_t a22)
+{
+	return
+		a00 * (a11 * a22 - a12 * a21)
+	-	a01 * (a10 * a22 - a12 * a20)
+	+	a02 * (a10 * a21 - a11 * a20);
+}
+
+void GetBestSurfaceTriangleMatchForBrushside(side_t *buildSide, bspDrawVert_t *bestVert[3])
+{
+	bspDrawSurface_t *s;
+	int i;
+	int t;
+	vec_t best = 0;
+	vec_t thisarea;
+	vec3_t normdiff;
+	vec3_t v1v0, v2v0, norm;
+	bspDrawVert_t *vert[3];
+	winding_t *polygon;
+	plane_t *buildPlane = &mapplanes[buildSide->planenum];
+	int matches = 0;
+
+	// first, start out with NULLs
+	bestVert[0] = bestVert[1] = bestVert[2] = NULL;
+
+	// brute force through all surfaces
+	for(s = bspDrawSurfaces; s != bspDrawSurfaces + numBSPDrawSurfaces; ++s)
+	{
+		if(s->surfaceType != MST_PLANAR && s->surfaceType != MST_TRIANGLE_SOUP)
+			continue;
+		if(strcmp(buildSide->shaderInfo->shader, bspShaders[s->shaderNum].shader))
+			continue;
+		for(t = 0; t + 3 <= s->numIndexes; t += 3)
+		{
+			vert[0] = &bspDrawVerts[s->firstVert + bspDrawIndexes[s->firstIndex + t + 0]];
+			vert[1] = &bspDrawVerts[s->firstVert + bspDrawIndexes[s->firstIndex + t + 1]];
+			vert[2] = &bspDrawVerts[s->firstVert + bspDrawIndexes[s->firstIndex + t + 2]];
+			if(s->surfaceType == MST_PLANAR)
+			{
+				VectorSubtract(vert[0]->normal, buildPlane->normal, normdiff); if(VectorLength(normdiff) >= normalEpsilon) continue;
+				VectorSubtract(vert[1]->normal, buildPlane->normal, normdiff); if(VectorLength(normdiff) >= normalEpsilon) continue;
+				VectorSubtract(vert[2]->normal, buildPlane->normal, normdiff); if(VectorLength(normdiff) >= normalEpsilon) continue;
+			}
+			else
+			{
+				// this is more prone to roundoff errors, but with embedded
+				// models, there is no better way
+				VectorSubtract(vert[1]->xyz, vert[0]->xyz, v1v0);
+				VectorSubtract(vert[2]->xyz, vert[0]->xyz, v2v0);
+				CrossProduct(v2v0, v1v0, norm);
+				VectorNormalize(norm, norm);
+				VectorSubtract(norm, buildPlane->normal, normdiff); if(VectorLength(normdiff) >= normalEpsilon) continue;
+			}
+			if(abs(DotProduct(vert[0]->xyz, buildPlane->normal) - buildPlane->dist) >= distanceEpsilon) continue;
+			if(abs(DotProduct(vert[1]->xyz, buildPlane->normal) - buildPlane->dist) >= distanceEpsilon) continue;
+			if(abs(DotProduct(vert[2]->xyz, buildPlane->normal) - buildPlane->dist) >= distanceEpsilon) continue;
+			// Okay. Correct surface type, correct shader, correct plane. Let's start with the business...
+			polygon = CopyWinding(buildSide->winding);
+			for(i = 0; i < 3; ++i)
+			{
+				// 0: 1, 2
+				// 1: 2, 0
+				// 2; 0, 1
+				vec3_t *v1 = &vert[(i+1)%3]->xyz;
+				vec3_t *v2 = &vert[(i+2)%3]->xyz;
+				vec3_t triNormal;
+				vec_t triDist;
+				vec3_t sideDirection;
+				// we now need to generate triNormal and triDist so that they represent the plane spanned by normal and (v2 - v1).
+				VectorSubtract(*v2, *v1, sideDirection);
+				CrossProduct(sideDirection, buildPlane->normal, triNormal);
+				triDist = DotProduct(*v1, triNormal);
+				ChopWindingInPlace(&polygon, triNormal, triDist, distanceEpsilon);
+				if(!polygon)
+					goto exwinding;
+			}
+			thisarea = WindingArea(polygon);
+			if(thisarea > 0)
+				++matches;
+			if(thisarea > best)
+			{
+				best = thisarea;
+				bestVert[0] = vert[0];
+				bestVert[1] = vert[1];
+				bestVert[2] = vert[2];
+			}
+			FreeWinding(polygon);
+exwinding:
+			;
+		}
+	}
+	//if(strncmp(buildSide->shaderInfo->shader, "textures/common/", 16))
+	//	fprintf(stderr, "brushside with %s: %d matches (%f area)\n", buildSide->shaderInfo->shader, matches, best);
+}
+
 static void ConvertBrush( FILE *f, int num, bspBrush_t *brush, vec3_t origin )
 {
 	int				i, j;
@@ -54,12 +153,17 @@
 	bspShader_t		*shader;
 	char			*texture;
 	bspPlane_t		*plane;
+	plane_t         *buildPlane;
 	vec3_t			pts[ 3 ];
+	bspDrawVert_t	*vert[3];
+	int valid;
 	
 	
 	/* start brush */
 	fprintf( f, "\t// brush %d\n", num );
 	fprintf( f, "\t{\n" );
+	fprintf( f, "\tbrushDef\n" );
+	fprintf( f, "\t{\n" );
 	
 	/* clear out build brush */
 	for( i = 0; i < buildBrush->numsides; i++ )
@@ -109,9 +213,88 @@
 		/* get build side */
 		buildSide = &buildBrush->sides[ i ];
 		
+		/* get plane */
+		buildPlane = &mapplanes[ buildSide->planenum ];
+
 		/* dummy check */
 		if( buildSide->shaderInfo == NULL || buildSide->winding == NULL )
 			continue;
+
+		// st-texcoords -> texMat block
+		// start out with dummy
+		VectorSet(buildSide->texMat[0], 1/32.0, 0, 0);
+		VectorSet(buildSide->texMat[1], 0, 1/32.0, 0);
+
+		// find surface for this side (by brute force)
+		// surface format:
+		//   - meshverts point in pairs of three into verts
+		//   - (triangles)
+		//   - find the triangle that has most in common with our side
+		GetBestSurfaceTriangleMatchForBrushside(buildSide, vert);
+		valid = 0;
+
+		if(vert[0] && vert[1] && vert[2])
+		{
+			int i;
+			vec3_t texX, texY;
+			vec3_t xy1I, xy1J, xy1K;
+			vec2_t stI, stJ, stK;
+			vec_t D, D0, D1, D2;
+
+			ComputeAxisBase(buildPlane->normal, texX, texY);
+
+			VectorSet(xy1I, DotProduct(vert[0]->xyz, texX), DotProduct(vert[0]->xyz, texY), 1);
+			VectorSet(xy1J, DotProduct(vert[1]->xyz, texX), DotProduct(vert[1]->xyz, texY), 1);
+			VectorSet(xy1K, DotProduct(vert[2]->xyz, texX), DotProduct(vert[2]->xyz, texY), 1);
+			stI[0] = vert[0]->st[0]; stI[1] = vert[0]->st[1];
+			stJ[0] = vert[1]->st[0]; stJ[1] = vert[1]->st[1];
+			stK[0] = vert[2]->st[0]; stK[1] = vert[2]->st[1];
+
+			//   - solve linear equations:
+			//     - (x, y) := xyz . (texX, texY)
+			//     - st[i] = texMat[i][0]*x + texMat[i][1]*y + texMat[i][2]
+			//       (for three vertices)
+			D = Det3x3(
+				xy1I[0], xy1I[1], 1,
+				xy1J[0], xy1J[1], 1,
+				xy1K[0], xy1K[1], 1
+			);
+			if(D != 0)
+			{
+				for(i = 0; i < 2; ++i)
+				{
+					D0 = Det3x3(
+						stI[i], xy1I[1], 1,
+						stJ[i], xy1J[1], 1,
+						stK[i], xy1K[1], 1
+					);
+					D1 = Det3x3(
+						xy1I[0], stI[i], 1,
+						xy1J[0], stJ[i], 1,
+						xy1K[0], stK[i], 1
+					);
+					D2 = Det3x3(
+						xy1I[0], xy1I[1], stI[i],
+						xy1J[0], xy1J[1], stJ[i],
+						xy1K[0], xy1K[1], stK[i]
+					);
+					VectorSet(buildSide->texMat[i], D0 / D, D1 / D, D2 / D);
+					valid = 1;
+				}
+			}
+			else
+				fprintf(stderr, "degenerate triangle found when solving texMat equations for\n(%f %f %f) (%f %f %f) (%f %f %f)\n( %f %f %f )\n( %f %f %f ) -> ( %f %f )\n( %f %f %f ) -> ( %f %f )\n( %f %f %f ) -> ( %f %f )\n",
+					buildPlane->normal[0], buildPlane->normal[1], buildPlane->normal[2],
+					vert[0]->normal[0], vert[0]->normal[1], vert[0]->normal[2],
+					texX[0], texX[1], texX[2], texY[0], texY[1], texY[2],
+					vert[0]->xyz[0], vert[0]->xyz[1], vert[0]->xyz[2], xy1I[0], xy1I[1],
+					vert[1]->xyz[0], vert[1]->xyz[1], vert[1]->xyz[2], xy1J[0], xy1J[1],
+					vert[2]->xyz[0], vert[2]->xyz[1], vert[2]->xyz[2], xy1K[0], xy1K[1]
+					);
+		}
+		else
+			if(strncmp(buildSide->shaderInfo->shader, "textures/common/", 16))
+				fprintf(stderr, "no matching triangle for brushside using %s (hopefully nobody can see this side anyway)\n", buildSide->shaderInfo->shader);
 		
 		/* get texture name */
 		if( !Q_strncasecmp( buildSide->shaderInfo->shader, "textures/", 9 ) )
@@ -130,14 +313,21 @@
 		
 		/* print brush side */
 		/* ( 640 24 -224 ) ( 448 24 -224 ) ( 448 -232 -224 ) common/caulk 0 48 0 0.500000 0.500000 0 0 0 */
-		fprintf( f, "\t\t( %.3f %.3f %.3f ) ( %.3f %.3f %.3f ) ( %.3f %.3f %.3f ) %s 0 0 0 0.5 0.5 0 0 0\n",
+		fprintf( f, "\t\t( %.3f %.3f %.3f ) ( %.3f %.3f %.3f ) ( %.3f %.3f %.3f ) ( ( %.8f %.8f %.8f ) ( %.8f %.8f %.8f ) ) %s %d 0 0\n",
 			pts[ 0 ][ 0 ], pts[ 0 ][ 1 ], pts[ 0 ][ 2 ],
 			pts[ 1 ][ 0 ], pts[ 1 ][ 1 ], pts[ 1 ][ 2 ],
 			pts[ 2 ][ 0 ], pts[ 2 ][ 1 ], pts[ 2 ][ 2 ],
-			texture );
+			buildSide->texMat[0][0], buildSide->texMat[0][1], buildSide->texMat[0][2],
+			buildSide->texMat[1][0], buildSide->texMat[1][1], buildSide->texMat[1][2],
+			texture,
+			// DEBUG: valid ? 0 : C_DETAIL
+			0
+			);
+		// TODO write brush primitives format here
 	}
 	
 	/* end brush */
+	fprintf( f, "\t}\n" );
 	fprintf( f, "\t}\n\n" );
 }
 
Index: tools/quake3/q3map2/main.c
===================================================================
--- tools/quake3/q3map2/main.c.orig	2008-09-06 15:32:05.000000000 +0200
+++ tools/quake3/q3map2/main.c	2008-09-06 15:32:11.000000000 +0200
@@ -541,6 +541,18 @@
 					Sys_Printf( "Unknown conversion format \"%s\". Defaulting to ASE.\n", argv[ i ] );
 			}
  		}
+		else if( !strcmp( argv[ i ],  "-ne" ) )
+ 		{
+			normalEpsilon = atof( argv[ i + 1 ] );
+ 			i++;
+			Sys_Printf( "Normal epsilon set to %f\n", normalEpsilon );
+ 		}
+		else if( !strcmp( argv[ i ],  "-de" ) )
+ 		{
+			distanceEpsilon = atof( argv[ i + 1 ] );
+ 			i++;
+			Sys_Printf( "Distance epsilon set to %f\n", distanceEpsilon );
+ 		}
 	}
 	
 	/* clean up map name */
