Index: tools/quake3/q3map2/light_ydnar.c
===================================================================
--- tools/quake3/q3map2/light_ydnar.c.orig	2008-09-06 15:32:16.000000000 +0200
+++ tools/quake3/q3map2/light_ydnar.c	2008-09-06 15:32:18.000000000 +0200
@@ -420,7 +420,7 @@
 #define NUDGE			0.5f
 #define BOGUS_NUDGE		-99999.0f
 
-static int MapSingleLuxel( rawLightmap_t *lm, surfaceInfo_t *info, bspDrawVert_t *dv, vec4_t plane, float pass, vec3_t stv[ 3 ], vec3_t ttv[ 3 ] )
+static int MapSingleLuxel( rawLightmap_t *lm, surfaceInfo_t *info, bspDrawVert_t *dv, vec4_t plane, float pass, vec3_t stv[ 3 ], vec3_t ttv[ 3 ], vec3_t worldverts[ 3 ] )
 {
 	int				i, x, y, numClusters, *clusters, pointCluster, *cluster;
 	float			*luxel, *origin, *normal, d, lightmapSampleOffset;
@@ -428,6 +428,12 @@
 	vec3_t			pNormal;
 	vec3_t			vecs[ 3 ];
 	vec3_t			nudged;
+	vec3_t			cverts[ 3 ];
+	vec3_t			temp;
+	vec4_t			sideplane, hostplane;
+	vec3_t			origintwo;
+	int				j, next;
+	float			e;
 	float			*nudge;
 	static float	nudges[][ 2 ] =
 					{
@@ -521,6 +527,51 @@
 	/* non axial lightmap projection (explicit xyz) */
 	else
 		VectorCopy( dv->xyz, origin );
+
+	//////////////////////
+	//27's test to make sure samples stay within the triangle boundaries
+	//1) Test the sample origin to see if it lays on the wrong side of any edge (x/y)
+	//2) if it does, nudge it onto the correct side.
+
+	if (worldverts!=NULL)
+	{
+		for (j=0;j<3;j++)
+		{
+			VectorCopy(worldverts[j],cverts[j]);
+		}
+		PlaneFromPoints(hostplane,cverts[0],cverts[1],cverts[2]);
+
+		for (j=0;j<3;j++)
+		{
+			for (i=0;i<3;i++)
+			{
+				//build plane using 2 edges and a normal
+				next=(i+1)%3;
+
+				VectorCopy(cverts[next],temp);
+				VectorAdd(temp,hostplane,temp);
+				PlaneFromPoints(sideplane,cverts[i],cverts[ next ], temp);
+
+				//planetest sample point
+				e=DotProduct(origin,sideplane);
+				e=e-sideplane[3];
+				if (e>0)
+				{
+					//we're bad.
+					//VectorClear(origin);
+					//Move the sample point back inside triangle bounds
+					origin[0]-=sideplane[0]*(e+1);
+					origin[1]-=sideplane[1]*(e+1);
+					origin[2]-=sideplane[2]*(e+1);
+#ifdef DEBUG_27_1
+					VectorClear(origin);
+#endif
+				}
+			}
+		}
+	}
+
+	////////////////////////
 	
 	/* planar surfaces have precalculated lightmap vectors for nudging */
 	if( lm->plane != NULL )
@@ -552,8 +603,13 @@
 	else
 		origin[ lm->axisNum ] += lightmapSampleOffset;
 	
+	VectorCopy(origin,origintwo);
+	origintwo[0]+=vecs[2][0];
+	origintwo[1]+=vecs[2][1];
+	origintwo[2]+=vecs[2][2];
+
 	/* get cluster */
-	pointCluster = ClusterForPointExtFilter( origin, LUXEL_EPSILON, numClusters, clusters );
+	pointCluster = ClusterForPointExtFilter( origintwo, LUXEL_EPSILON, numClusters, clusters );
 	
 	/* another retarded hack, storing nudge count in luxel[ 1 ] */
 	luxel[ 1 ] = 0.0f;	
@@ -569,14 +625,14 @@
 			for( i = 0; i < 3; i++ )
 			{
 				/* set nudged point*/
-				nudged[ i ] = origin[ i ] + (nudge[ 0 ] * vecs[ 0 ][ i ]) + (nudge[ 1 ] * vecs[ 1 ][ i ]);
+				nudged[ i ] = origintwo[ i ] + (nudge[ 0 ] * vecs[ 0 ][ i ]) + (nudge[ 1 ] * vecs[ 1 ][ i ]);
 			}
 			nudge += 2;
 			
 			/* get pvs cluster */
 			pointCluster = ClusterForPointExtFilter( nudged, LUXEL_EPSILON, numClusters, clusters ); //% + 0.625 );
-			if( pointCluster >= 0 )	
-				VectorCopy( nudged, origin );
+			//if( pointCluster >= 0 )
+   			//	VectorCopy( nudged, origin );
 			luxel[ 1 ] += 1.0f;
 		}
 	}
@@ -586,8 +642,8 @@
 	{
 		VectorMA( dv->xyz, lightmapSampleOffset, dv->normal, nudged );
 		pointCluster = ClusterForPointExtFilter( nudged, LUXEL_EPSILON, numClusters, clusters );
-		if( pointCluster >= 0 )
-			VectorCopy( nudged, origin );
+		//if( pointCluster >= 0 )
+		//	VectorCopy( nudged, origin );
 		luxel[ 1 ] += 1.0f;
 	}
 	
@@ -633,7 +689,7 @@
 than the distance between two luxels (thanks jc :)
 */
 
-static void MapTriangle_r( rawLightmap_t *lm, surfaceInfo_t *info, bspDrawVert_t *dv[ 3 ], vec4_t plane, vec3_t stv[ 3 ], vec3_t ttv[ 3 ] )
+static void MapTriangle_r( rawLightmap_t *lm, surfaceInfo_t *info, bspDrawVert_t *dv[ 3 ], vec4_t plane, vec3_t stv[ 3 ], vec3_t ttv[ 3 ], vec3_t worldverts[ 3 ] )
 {
 	bspDrawVert_t	mid, *dv2[ 3 ];
 	int				max;
@@ -681,7 +737,7 @@
 	
 	/* split the longest edge and map it */
 	LerpDrawVert( dv[ max ], dv[ (max + 1) % 3 ], &mid );
-	MapSingleLuxel( lm, info, &mid, plane, 1, stv, ttv );
+	MapSingleLuxel( lm, info, &mid, plane, 1, stv, ttv, worldverts );
 	
 	/* push the point up a little bit to account for fp creep (fixme: revisit this) */
 	//%	VectorMA( mid.xyz, 2.0f, mid.normal, mid.xyz );
@@ -689,12 +745,12 @@
 	/* recurse to first triangle */
 	VectorCopy( dv, dv2 );
 	dv2[ max ] = &mid;
-	MapTriangle_r( lm, info, dv2, plane, stv, ttv );
+	MapTriangle_r( lm, info, dv2, plane, stv, ttv, worldverts );
 	
 	/* recurse to second triangle */
 	VectorCopy( dv, dv2 );
 	dv2[ (max + 1) % 3 ] = &mid;
-	MapTriangle_r( lm, info, dv2, plane, stv, ttv );
+	MapTriangle_r( lm, info, dv2, plane, stv, ttv, worldverts );
 }
 
 
@@ -710,6 +766,7 @@
 	int				i;
 	vec4_t			plane;
 	vec3_t			*stv, *ttv, stvStatic[ 3 ], ttvStatic[ 3 ];
+	vec3_t			worldverts[ 3 ];
 	
 	
 	/* get plane if possible */
@@ -735,16 +792,20 @@
 		ttv = NULL;
 	}
 	
+	VectorCopy( dv[ 0 ]->xyz, worldverts[ 0 ] );
+	VectorCopy( dv[ 1 ]->xyz, worldverts[ 1 ] );
+	VectorCopy( dv[ 2 ]->xyz, worldverts[ 2 ] );
+
 	/* map the vertexes */
-	MapSingleLuxel( lm, info, dv[ 0 ], plane, 1, stv, ttv );
-	MapSingleLuxel( lm, info, dv[ 1 ], plane, 1, stv, ttv );
-	MapSingleLuxel( lm, info, dv[ 2 ], plane, 1, stv, ttv );
+	MapSingleLuxel( lm, info, dv[ 0 ], plane, 1, stv, ttv, worldverts );
+	MapSingleLuxel( lm, info, dv[ 1 ], plane, 1, stv, ttv, worldverts );
+	MapSingleLuxel( lm, info, dv[ 2 ], plane, 1, stv, ttv, worldverts );
 	
 	/* 2002-11-20: prefer axial triangle edges */
 	if( mapNonAxial )
 	{
 		/* subdivide the triangle */
-		MapTriangle_r( lm, info, dv, plane, stv, ttv );
+		MapTriangle_r( lm, info, dv, plane, stv, ttv, worldverts );
 		return qtrue;
 	}
 	
@@ -766,7 +827,7 @@
 			dv2[ 2 ] = dv[ (i + 1) % 3 ];
 			
 			/* map the degenerate triangle */
-			MapTriangle_r( lm, info, dv2, plane, stv, ttv );
+			MapTriangle_r( lm, info, dv2, plane, stv, ttv, worldverts );
 		}
 	}
 	
@@ -828,8 +889,8 @@
 	LerpDrawVert( dv[ max + 2 ], dv[ (max + 3) % 4 ], &mid[ 1 ] );
 	
 	/* map the vertexes */
-	MapSingleLuxel( lm, info, &mid[ 0 ], plane, 1, stv, ttv );
-	MapSingleLuxel( lm, info, &mid[ 1 ], plane, 1, stv, ttv );
+	MapSingleLuxel( lm, info, &mid[ 0 ], plane, 1, stv, ttv, NULL );
+	MapSingleLuxel( lm, info, &mid[ 1 ], plane, 1, stv, ttv, NULL );
 	
 	/* 0 and 2 */
 	if( max == 0 )
@@ -914,10 +975,10 @@
 	}
 	
 	/* map the vertexes */
-	MapSingleLuxel( lm, info, dv[ 0 ], plane, 1, stv, ttv );
-	MapSingleLuxel( lm, info, dv[ 1 ], plane, 1, stv, ttv );
-	MapSingleLuxel( lm, info, dv[ 2 ], plane, 1, stv, ttv );
-	MapSingleLuxel( lm, info, dv[ 3 ], plane, 1, stv, ttv );
+	MapSingleLuxel( lm, info, dv[ 0 ], plane, 1, stv, ttv, NULL );
+	MapSingleLuxel( lm, info, dv[ 1 ], plane, 1, stv, ttv, NULL );
+	MapSingleLuxel( lm, info, dv[ 2 ], plane, 1, stv, ttv, NULL );
+	MapSingleLuxel( lm, info, dv[ 3 ], plane, 1, stv, ttv, NULL );
 	
 	/* subdivide the quad */
 	MapQuad_r( lm, info, dv, plane, stv, ttv );
@@ -1209,7 +1270,7 @@
 					continue;
 				
 				/* map the fake vert */
-				MapSingleLuxel( lm, NULL, &fake, lm->plane, pass, NULL, NULL );
+				MapSingleLuxel( lm, NULL, &fake, lm->plane, pass, NULL, NULL, NULL );
 			}
 		}
 	}
@@ -2001,22 +2062,32 @@
 					deluxel = SUPER_DELUXEL( x, y );
 					origin = SUPER_ORIGIN( x, y );
 					normal = SUPER_NORMAL( x, y );
-					
-					/* set contribution count */
-					lightLuxel[ 3 ] = 1.0f;
-					
-					/* setup trace */
-					trace.cluster = *cluster;
-					VectorCopy( origin, trace.origin );
-					VectorCopy( normal, trace.normal );
-					
-					/* get light for this sample */
-					LightContributionToSample( &trace );
-					VectorCopy( trace.color, lightLuxel );
-					
-					/* add to count */
-					if( trace.color[ 0 ] || trace.color[ 1 ] || trace.color[ 2 ] )
+
+					////////// 27's temp hack for testing edge clipping ////
+					if( origin[0]==0 && origin[1]==0 && origin[2]==0 )
+					{
+						lightLuxel[ 1 ] = 255;
+						lightLuxel[ 3 ] = 1.0f;
 						totalLighted++;
+					}
+					else
+					{
+						/* set contribution count */
+						lightLuxel[ 3 ] = 1.0f;
+
+						/* setup trace */
+						trace.cluster = *cluster;
+						VectorCopy( origin, trace.origin );
+						VectorCopy( normal, trace.normal );
+
+						/* get light for this sample */
+						LightContributionToSample( &trace );
+						VectorCopy( trace.color, lightLuxel );
+
+						/* add to count */
+						if( trace.color[ 0 ] || trace.color[ 1 ] || trace.color[ 2 ] )
+							totalLighted++;
+					}
 					
 					/* add to light direction map (fixme: use luxel normal as starting point for deluxel?) */
 					if( deluxemap )
