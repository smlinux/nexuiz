NOTE: this patch set is autogenerated from the "singlepatches" subdirectory of nexuiz/trunk/misc.

Do not commit changes to THIS!

Always run
	sh mergepatches.sh > gtkradiant-nexuiz-patchset.diff
before committing new singlepatches!



Index: libs/picomodel/pm_obj.c
===================================================================
--- libs/picomodel/pm_obj.c.orig	2008-09-06 15:32:05.000000000 +0200
+++ libs/picomodel/pm_obj.c	2008-09-06 15:32:09.000000000 +0200
@@ -215,10 +215,9 @@
 	}
 }
 
-#if 0
 static int _obj_mtl_load( picoModel_t *model )
 {
-	//picoShader_t *curShader = NULL;
+	picoShader_t *curShader = NULL;
 	picoParser_t *p;
 	picoByte_t   *mtlBuffer;
 	int			  mtlBufSize;
@@ -266,7 +265,7 @@
 		/* get next token in material file */
 		if (_pico_parse( p,1 ) == NULL)
 			break;
-#if 0
+#if 1
 
 		/* skip empty lines */
 		if (p->token == NULL || !strlen( p->token ))
@@ -308,6 +307,7 @@
 		else if (!_pico_stricmp(p->token,"map_kd"))
 		{
 			char *mapName;
+			picoShader_t *shader;
 
 			/* pointer to current shader must be valid */
 			if (curShader == NULL)
@@ -322,6 +322,10 @@
 				_pico_printf( PICO_ERROR,"Missing material map name in MTL, line %d.",p->curLine);
 				_obj_mtl_error_return;
 			}
+			/* create a new pico shader */
+			shader = PicoNewShader( model );
+			if (shader == NULL)
+				_obj_mtl_error_return;
 			/* set shader map name */
 			PicoSetShaderMapName( shader,mapName );
 		}
@@ -478,7 +482,6 @@
 	/* return with success */
 	return 1;
 }
-#endif
 
 /* _obj_load:
  *  loads a wavefront obj model file.
@@ -523,7 +526,7 @@
 	PicoSetModelFileName( model,fileName );
 
 	/* try loading the materials; we don't handle the result */
-#if 0
+#if 1
 	_obj_mtl_load( model );
 #endif
 
@@ -832,6 +835,41 @@
 				curVertex += max;
 			}
 		}
+		else if (!_pico_stricmp(p->token,"usemtl"))
+		{
+			picoShader_t *shader;
+			char *name;
+
+			/* get material name */
+			name = _pico_parse( p,0 );
+
+			/* validate material name */
+			if (name == NULL || !strlen(name))
+			{
+				_pico_printf( PICO_ERROR,"Missing material name in OBJ, line %d.",p->curLine);
+			}
+			else
+			{
+				shader = PicoFindShader( model, name, 1 );
+				if (shader == NULL)
+				{
+					_pico_printf( PICO_ERROR,"Undefined material name in OBJ, line %d. Making a default shader.",p->curLine);
+
+					/* create a new pico shader */
+					shader = PicoNewShader( model );
+					if (shader != NULL)
+					{
+						PicoSetShaderName( shader,name );
+						PicoSetShaderMapName( shader,name );
+						PicoSetSurfaceShader( curSurface, shader );
+					}
+				}
+				else
+				{
+					PicoSetSurfaceShader( curSurface, shader );
+				}
+			}
+		}
 		/* skip unparsed rest of line and continue */
 		_pico_parse_skip_rest( p );
 	}
Index: radiant/map.cpp
===================================================================
--- radiant/map.cpp.orig	2008-09-06 15:32:05.000000000 +0200
+++ radiant/map.cpp	2008-09-06 15:32:10.000000000 +0200
@@ -270,6 +270,100 @@
   ents->RemoveAll();
 }
 
+void Map_DoTargetFix(entity_t *e, const char *target, int num_ents, CPtrArray *ents, GPtrArray *new_ents)
+{
+	int j;
+	int id;
+	char newtarget[128];
+	entity_t *e_target;
+
+	qboolean targetnameFound = FALSE;
+	qboolean targetFound = FALSE;
+	qboolean colliding = FALSE;
+
+	if(!target)
+		return;
+	if(!*target)
+		return;
+
+	target = g_strdup(target);
+
+	// check the current map entities for an actual collision
+	for (e_target = entities.next; e_target != &entities; e_target = e_target->next)
+	{
+		if(
+			!strcmp(target, ValueForKey(e_target, "target"))
+			||
+			!strcmp(target, ValueForKey(e_target, "killtarget"))
+		)
+		{
+			// make sure the collision is not between two imported entities
+			for(j=0; j<(int)new_ents->len; j++)
+			{
+				if(e_target == g_ptr_array_index(new_ents, j))
+				{
+					targetFound = true;
+					goto no_collision_yet_1;
+				}
+			}
+			colliding = TRUE;
+no_collision_yet_1:
+			;
+		}
+		if(
+			!strcmp(target, ValueForKey(e_target, "targetname"))
+		)
+		{
+			// make sure the collision is not between two imported entities
+			for(j=0; j<(int)new_ents->len; j++)
+			{
+				if(e_target == g_ptr_array_index(new_ents, j))
+				{
+					targetnameFound = true;
+					goto no_collision_yet_2;
+				}
+			}
+			colliding = TRUE;
+no_collision_yet_2:
+			;
+		}
+	}
+
+	// find the matching targeted entity(s)
+	if(colliding && targetFound && targetnameFound)
+	{
+		// We got a collision
+		// first look for a non-conflicting target name
+		id = GetUniqueTargetId(1);
+		sprintf(newtarget, "t%i", id);
+
+		for(j=num_ents-1; j>0; j--)
+		{
+			e_target = (entity_t*)ents->GetAt(j);
+			if(e_target != NULL)
+			{
+				const char *targetname = ValueForKey(e_target, "targetname");
+				if( (targetname != NULL) && (strcmp(target, targetname) == 0) )
+				{
+					SetKeyValue(e_target, "targetname", newtarget);
+				}
+				targetname = ValueForKey(e_target, "target");
+				if( (targetname != NULL) && (strcmp(target, targetname) == 0) )
+				{
+					SetKeyValue(e_target, "target", newtarget);
+				}
+				targetname = ValueForKey(e_target, "killtarget");
+				if( (targetname != NULL) && (strcmp(target, targetname) == 0) )
+				{
+					SetKeyValue(e_target, "killtarget", newtarget);
+				}
+			}
+		}
+	}
+
+	g_free(target);
+}
+
 /*!\todo Possibly make the import Undo-friendly by calling Undo_End for new brushes and ents */
 void Map_ImportEntities(CPtrArray *ents, bool bAddSelected = false)
 {
@@ -466,60 +560,27 @@
     }
     else
     {
-      // fix target/targetname collisions
-      if ((g_PrefsDlg.m_bDoTargetFix) && (strcmp(ValueForKey(e, "target"), "") != 0))
-      {
-        GPtrArray *t_ents = g_ptr_array_new();
-        entity_t *e_target;
-        const char *target = ValueForKey(e, "target");
-        qboolean bCollision=FALSE;
-
-        // check the current map entities for an actual collision
-        for (e_target = entities.next; e_target != &entities; e_target = e_target->next)
-        {
-          if(!strcmp(target, ValueForKey(e_target, "target")))
-          {
-            bCollision = TRUE;
-            // make sure the collision is not between two imported entities
-            for(j=0; j<(int)new_ents->len; j++)
-            {
-              if(e_target == g_ptr_array_index(new_ents, j))
-                bCollision = FALSE;
-            }
-          }
-        }
-
-        // find the matching targeted entity(s)
-        if(bCollision)
-        {
-          for(j=num_ents-1; j>0; j--)
-          {
-            e_target = (entity_t*)ents->GetAt(j);
-            if(e_target != NULL && e_target != e)
-            {
-              const char *targetname = ValueForKey(e_target, "targetname");
-              if( (targetname != NULL) && (strcmp(target, targetname) == 0) )
-                g_ptr_array_add(t_ents, (gpointer)e_target);
-            }
-          }
-          if(t_ents->len > 0)
-          {
-            // link the first to get a unique target/targetname
-            Entity_Connect(e, (entity_t*)g_ptr_array_index(t_ents,0));
-            // set the targetname of the rest of them manually
-            for(j = 1; j < (int)t_ents->len; j++)
-              SetKeyValue( (entity_t*)g_ptr_array_index(t_ents, j), "targetname", ValueForKey(e, "target") );
-          }
-          g_ptr_array_free(t_ents, FALSE);
-        }
-      }
+      // keep a list of ents added to avoid testing collisions against them
+      g_ptr_array_add(new_ents, (gpointer)e);
 
       // add the entity to the end of the entity list
       Entity_AddToList(e, &entities);
       g_qeglobals.d_num_entities++;
 
-      // keep a list of ents added to avoid testing collisions against them
-      g_ptr_array_add(new_ents, (gpointer)e);
+      // fix target/targetname collisions
+      if (g_PrefsDlg.m_bDoTargetFix)
+	  {
+		  const char *target;
+
+		  target = ValueForKey(e, "target");
+		  Map_DoTargetFix(e, target, num_ents, ents, new_ents);
+
+		  target = ValueForKey(e, "killtarget");
+		  Map_DoTargetFix(e, target, num_ents, ents, new_ents);
+
+		  target = ValueForKey(e, "targetname");
+		  Map_DoTargetFix(e, target, num_ents, ents, new_ents);
+	  }
     }
   }
   g_ptr_array_free(new_ents, FALSE);
Index: radiant/drag.cpp
===================================================================
--- radiant/drag.cpp.orig	2008-09-06 15:32:05.000000000 +0200
+++ radiant/drag.cpp	2008-09-06 15:32:10.000000000 +0200
@@ -255,54 +255,6 @@
 
 entity_t *peLink;
 
-void UpdateTarget(vec3_t origin, vec3_t dir)
-{
-	trace_t	t;
-	entity_t *pe;
-	int i;
-	char sz[128];
-
-	t = Test_Ray (origin, dir, 0);
-
-	if (!t.brush)
-		return;
-
-	pe = t.brush->owner;
-
-	if (pe == NULL)
-		return;
-
-	// is this the first?
-	if (peLink != NULL)
-	{
-
-		// Get the target id from out current target
-		// if there is no id, make one
-
-		i = IntForKey(pe, "target");
-		if (i <= 0)
-		{
-			i = GetUniqueTargetId(1);
-			sprintf(sz, "%d", i);
-
-			SetKeyValue(pe, "target", sz);
-		}
-
-		// set the target # into our src
-
-		sprintf(sz, "%d", i);
-		SetKeyValue(peLink, "targetname", sz);
-
-		Sys_UpdateWindows(W_ENTITY);
-
-	}
-
-	// promote the target to the src
-
-	peLink = pe;
-
-}
-
 /*
 ===========
 Drag_Begin
Index: radiant/xywindow.cpp
===================================================================
--- radiant/xywindow.cpp.orig	2008-09-06 15:32:05.000000000 +0200
+++ radiant/xywindow.cpp	2008-09-06 15:32:10.000000000 +0200
@@ -270,16 +270,17 @@
 void DrawPathLines (void)
 {
   int       i, j, k;
-  vec3_t    mid, mid1;
+  vec3_t    mid, mid1, v;
   entity_t *se, *te;
   brush_t   *sb, *tb;
   const char    *psz;
-  vec3_t    dir, s1, s2;
+  vec3_t    dir, s1, s2, dirortho;
   vec_t len, f;
   int       arrows;
   int           num_entities;
   const char        *ent_target[MAX_MAP_ENTITIES];
   entity_t  *ent_entity[MAX_MAP_ENTITIES];
+  int lines;
 
   if (g_qeglobals.d_savedinfo.exclude & EXCLUDE_PATHS)
   {
@@ -295,6 +296,12 @@
       ent_entity[num_entities] = te;
       num_entities++;
     }
+    ent_target[num_entities] = ValueForKey (te, "killtarget");
+    if (ent_target[num_entities][0])
+    {
+      ent_entity[num_entities] = te;
+      num_entities++;
+    }
   }
 
   for (se = entities.next ; se != &entities ; se = se->next)
@@ -308,6 +315,9 @@
     if (sb == &se->brushes)
       continue;
 
+	for (i=0 ; i<3 ; i++)
+		mid[i] = (sb->mins[i] + sb->maxs[i])*0.5;
+
     for (k=0 ; k<num_entities ; k++)
     {
       if (strcmp (ent_target[k], psz))
@@ -318,14 +328,20 @@
       if (tb == &te->brushes)
         continue;
 
-      for (i=0 ; i<3 ; i++)
-        mid[i] = (sb->mins[i] + sb->maxs[i])*0.5;
+	  lines = 0;
+	  if(!strcmp(ValueForKey(te, "target"), psz))
+		  lines += 1;
+	  if(!strcmp(ValueForKey(te, "killtarget"), psz))
+		  lines += 2;
 
       for (i=0 ; i<3 ; i++)
         mid1[i] = (tb->mins[i] + tb->maxs[i])*0.5;
 
       VectorSubtract (mid1, mid, dir);
       len = VectorNormalize (dir, dir);
+	  dirortho[0] = -dir[1];
+	  dirortho[1] = dir[0];
+	  dirortho[2] = 0;
       s1[0] = -dir[1]*8 + dir[0]*8;
       s2[0] = dir[1]*8 + dir[0]*8;
       s1[1] = dir[0]*8 + dir[1]*8;
@@ -334,8 +350,13 @@
       qglColor3f (se->eclass->color[0], se->eclass->color[1], se->eclass->color[2]);
 
       qglBegin(GL_LINES);
-      qglVertex3fv(mid);
-      qglVertex3fv(mid1);
+	  for(i = -lines + 1; i < lines; i += 2)
+	  {
+		  VectorMA(mid, i, dirortho, v);
+		  qglVertex3fv(v);
+		  VectorMA(mid1, i, dirortho, v);
+		  qglVertex3fv(v);
+	  }
 
       arrows = (int)(len / 256) + 1;
 
Index: radiant/targetname.cpp
===================================================================
--- radiant/targetname.cpp.orig	2008-09-06 15:32:05.000000000 +0200
+++ radiant/targetname.cpp	2008-09-06 15:32:10.000000000 +0200
@@ -24,11 +24,11 @@
 /*!
 connects two entities creating a unique target/targetname value 
 */
-void Entity_Connect(entity_t *e1, entity_t *e2)
+void Entity_Connect(entity_t *e1, entity_t *e2, bool kill)
 {
   const char *maptarget;
   char newtarget[16];
-  int maxtarget=0;  // highest t# value in the map
+  int id=0;  // highest t# value in the map
   entity_t *e;      // map entities
 
   if (e1 == e2)
@@ -39,47 +39,54 @@
 		return;
 	}
 
-  for (e=entities.next ; e != &entities ; e=e->next)
-  {
-    maptarget = ValueForKey (e, "target");
-    if (maptarget && maptarget[0])
-    {
-      int targetnum = atoi(maptarget+1);
-      if (targetnum > maxtarget)
-        maxtarget = targetnum;
-    }
-  }
-  sprintf (newtarget, "t%i", maxtarget+1);
+	id = GetUniqueTargetId(1);
+	sprintf (newtarget, "t%i", id);
   
 #ifdef _DEBUG
   Sys_Printf("Connecting entities with new target/targetname: %s\n", newtarget);
 #endif  
   
-	SetKeyValue (e1, "target", newtarget);
+  	if(kill)
+		SetKeyValue (e1, "killtarget", newtarget);
+	else
+		SetKeyValue (e1, "target", newtarget);
 	SetKeyValue (e2, "targetname", newtarget);
 }
 
+static int TargetIdForKey(entity_t *pe, const char *key)
+{
+	const char *p = ValueForKey(pe, key);
+	if(!p)
+		return 0;
+	if(!*p)
+		return 0;
+	return atoi(p + 1);
+}
+
 int GetUniqueTargetId(int iHint)
 {
-	int iMin, iMax, i;
+	int iMax, i;
 	bool fFound;
 	entity_t *pe;
 	
 	fFound = FALSE;
 	pe = entities.next;
-	iMin = 0; 
 	iMax = 0;
 	
 	for (; pe != NULL && pe != &entities ; pe = pe->next)
 	{
-		i = IntForKey(pe, "target");
-		if (i)
-		{
-			iMin = MIN(i, iMin);
-			iMax = MAX(i, iMax);
-			if (i == iHint)
-				fFound = TRUE;
-		}
+		i = TargetIdForKey(pe, "target");
+		iMax = MAX(i, iMax);
+		if (i == iHint)
+			fFound = TRUE;
+		i = TargetIdForKey(pe, "targetname");
+		iMax = MAX(i, iMax);
+		if (i == iHint)
+			fFound = TRUE;
+		i = TargetIdForKey(pe, "killtarget");
+		iMax = MAX(i, iMax);
+		if (i == iHint)
+			fFound = TRUE;
 	}
 
 	if (fFound)
Index: radiant/qe3.cpp
===================================================================
--- radiant/qe3.cpp.orig	2008-09-06 15:32:05.000000000 +0200
+++ radiant/qe3.cpp	2008-09-06 15:32:10.000000000 +0200
@@ -704,7 +704,7 @@
 from the first selected to the secon
 ===============
 */
-void ConnectEntities (void)
+void ConnectEntities (bool kill)
 {
 	entity_t	*e1, *e2;
 	const char		*target;
@@ -734,7 +734,7 @@
 		return;
 	}
 
-  target = ValueForKey (e1, "target");
+  target = ValueForKey (e1, kill ? "killtarget" : "target");
   if (target && target[0])
     newtarg = g_strdup(target);
   else
@@ -743,12 +743,12 @@
     if(target && target[0])
       newtarg = g_strdup(target);
     else
-      Entity_Connect(e1, e2);
+      Entity_Connect(e1, e2, kill);
   }
 
   if(newtarg != NULL)
   {
-    SetKeyValue(e1, "target", newtarg);
+    SetKeyValue(e1, kill ? "killtarget" : "target", newtarg);
     SetKeyValue(e2, "targetname", newtarg);
     g_free(newtarg);
   }
Index: radiant/qe3.h
===================================================================
--- radiant/qe3.h.orig	2008-09-06 15:32:05.000000000 +0200
+++ radiant/qe3.h	2008-09-06 15:32:10.000000000 +0200
@@ -229,7 +229,7 @@
 void SelectEdgeByRay (vec3_t org, vec3_t dir);
 void SelectVertexByRay (vec3_t org, vec3_t dir);
 
-void ConnectEntities (void);
+void ConnectEntities (bool kill = false);
 
 extern	int	update_bits;
 
@@ -878,7 +878,7 @@
 
 // SPoG
 // targetname.cpp
-void Entity_Connect(entity_t *e1, entity_t *e2);
+void Entity_Connect(entity_t *e1, entity_t *e2, bool kill = false);
 int GetUniqueTargetId(int iHint);
 
 // xywindow.cpp
Index: tools/quake3/q3map2/convert_map.c
===================================================================
--- tools/quake3/q3map2/convert_map.c.orig	2008-09-06 15:32:05.000000000 +0200
+++ tools/quake3/q3map2/convert_map.c	2008-09-06 15:32:11.000000000 +0200
@@ -46,6 +46,105 @@
 #define	SNAP_FLOAT_TO_INT	4
 #define	SNAP_INT_TO_FLOAT	(1.0 / SNAP_FLOAT_TO_INT)
 
+typedef vec_t vec2_t[2];
+
+static vec_t Det3x3(vec_t a00, vec_t a01, vec_t a02,
+                    vec_t a10, vec_t a11, vec_t a12,
+                    vec_t a20, vec_t a21, vec_t a22)
+{
+	return
+		a00 * (a11 * a22 - a12 * a21)
+	-	a01 * (a10 * a22 - a12 * a20)
+	+	a02 * (a10 * a21 - a11 * a20);
+}
+
+void GetBestSurfaceTriangleMatchForBrushside(side_t *buildSide, bspDrawVert_t *bestVert[3])
+{
+	bspDrawSurface_t *s;
+	int i;
+	int t;
+	vec_t best = 0;
+	vec_t thisarea;
+	vec3_t normdiff;
+	vec3_t v1v0, v2v0, norm;
+	bspDrawVert_t *vert[3];
+	winding_t *polygon;
+	plane_t *buildPlane = &mapplanes[buildSide->planenum];
+	int matches = 0;
+
+	// first, start out with NULLs
+	bestVert[0] = bestVert[1] = bestVert[2] = NULL;
+
+	// brute force through all surfaces
+	for(s = bspDrawSurfaces; s != bspDrawSurfaces + numBSPDrawSurfaces; ++s)
+	{
+		if(s->surfaceType != MST_PLANAR && s->surfaceType != MST_TRIANGLE_SOUP)
+			continue;
+		if(strcmp(buildSide->shaderInfo->shader, bspShaders[s->shaderNum].shader))
+			continue;
+		for(t = 0; t + 3 <= s->numIndexes; t += 3)
+		{
+			vert[0] = &bspDrawVerts[s->firstVert + bspDrawIndexes[s->firstIndex + t + 0]];
+			vert[1] = &bspDrawVerts[s->firstVert + bspDrawIndexes[s->firstIndex + t + 1]];
+			vert[2] = &bspDrawVerts[s->firstVert + bspDrawIndexes[s->firstIndex + t + 2]];
+			if(s->surfaceType == MST_PLANAR)
+			{
+				VectorSubtract(vert[0]->normal, buildPlane->normal, normdiff); if(VectorLength(normdiff) >= normalEpsilon) continue;
+				VectorSubtract(vert[1]->normal, buildPlane->normal, normdiff); if(VectorLength(normdiff) >= normalEpsilon) continue;
+				VectorSubtract(vert[2]->normal, buildPlane->normal, normdiff); if(VectorLength(normdiff) >= normalEpsilon) continue;
+			}
+			else
+			{
+				// this is more prone to roundoff errors, but with embedded
+				// models, there is no better way
+				VectorSubtract(vert[1]->xyz, vert[0]->xyz, v1v0);
+				VectorSubtract(vert[2]->xyz, vert[0]->xyz, v2v0);
+				CrossProduct(v2v0, v1v0, norm);
+				VectorNormalize(norm, norm);
+				VectorSubtract(norm, buildPlane->normal, normdiff); if(VectorLength(normdiff) >= normalEpsilon) continue;
+			}
+			if(abs(DotProduct(vert[0]->xyz, buildPlane->normal) - buildPlane->dist) >= distanceEpsilon) continue;
+			if(abs(DotProduct(vert[1]->xyz, buildPlane->normal) - buildPlane->dist) >= distanceEpsilon) continue;
+			if(abs(DotProduct(vert[2]->xyz, buildPlane->normal) - buildPlane->dist) >= distanceEpsilon) continue;
+			// Okay. Correct surface type, correct shader, correct plane. Let's start with the business...
+			polygon = CopyWinding(buildSide->winding);
+			for(i = 0; i < 3; ++i)
+			{
+				// 0: 1, 2
+				// 1: 2, 0
+				// 2; 0, 1
+				vec3_t *v1 = &vert[(i+1)%3]->xyz;
+				vec3_t *v2 = &vert[(i+2)%3]->xyz;
+				vec3_t triNormal;
+				vec_t triDist;
+				vec3_t sideDirection;
+				// we now need to generate triNormal and triDist so that they represent the plane spanned by normal and (v2 - v1).
+				VectorSubtract(*v2, *v1, sideDirection);
+				CrossProduct(sideDirection, buildPlane->normal, triNormal);
+				triDist = DotProduct(*v1, triNormal);
+				ChopWindingInPlace(&polygon, triNormal, triDist, distanceEpsilon);
+				if(!polygon)
+					goto exwinding;
+			}
+			thisarea = WindingArea(polygon);
+			if(thisarea > 0)
+				++matches;
+			if(thisarea > best)
+			{
+				best = thisarea;
+				bestVert[0] = vert[0];
+				bestVert[1] = vert[1];
+				bestVert[2] = vert[2];
+			}
+			FreeWinding(polygon);
+exwinding:
+			;
+		}
+	}
+	//if(strncmp(buildSide->shaderInfo->shader, "textures/common/", 16))
+	//	fprintf(stderr, "brushside with %s: %d matches (%f area)\n", buildSide->shaderInfo->shader, matches, best);
+}
+
 static void ConvertBrush( FILE *f, int num, bspBrush_t *brush, vec3_t origin )
 {
 	int				i, j;
@@ -54,12 +153,17 @@
 	bspShader_t		*shader;
 	char			*texture;
 	bspPlane_t		*plane;
+	plane_t         *buildPlane;
 	vec3_t			pts[ 3 ];
+	bspDrawVert_t	*vert[3];
+	int valid;
 	
 	
 	/* start brush */
 	fprintf( f, "\t// brush %d\n", num );
 	fprintf( f, "\t{\n" );
+	fprintf( f, "\tbrushDef\n" );
+	fprintf( f, "\t{\n" );
 	
 	/* clear out build brush */
 	for( i = 0; i < buildBrush->numsides; i++ )
@@ -109,9 +213,88 @@
 		/* get build side */
 		buildSide = &buildBrush->sides[ i ];
 		
+		/* get plane */
+		buildPlane = &mapplanes[ buildSide->planenum ];
+
 		/* dummy check */
 		if( buildSide->shaderInfo == NULL || buildSide->winding == NULL )
 			continue;
+
+		// st-texcoords -> texMat block
+		// start out with dummy
+		VectorSet(buildSide->texMat[0], 1/32.0, 0, 0);
+		VectorSet(buildSide->texMat[1], 0, 1/32.0, 0);
+
+		// find surface for this side (by brute force)
+		// surface format:
+		//   - meshverts point in pairs of three into verts
+		//   - (triangles)
+		//   - find the triangle that has most in common with our side
+		GetBestSurfaceTriangleMatchForBrushside(buildSide, vert);
+		valid = 0;
+
+		if(vert[0] && vert[1] && vert[2])
+		{
+			int i;
+			vec3_t texX, texY;
+			vec3_t xy1I, xy1J, xy1K;
+			vec2_t stI, stJ, stK;
+			vec_t D, D0, D1, D2;
+
+			ComputeAxisBase(buildPlane->normal, texX, texY);
+
+			VectorSet(xy1I, DotProduct(vert[0]->xyz, texX), DotProduct(vert[0]->xyz, texY), 1);
+			VectorSet(xy1J, DotProduct(vert[1]->xyz, texX), DotProduct(vert[1]->xyz, texY), 1);
+			VectorSet(xy1K, DotProduct(vert[2]->xyz, texX), DotProduct(vert[2]->xyz, texY), 1);
+			stI[0] = vert[0]->st[0]; stI[1] = vert[0]->st[1];
+			stJ[0] = vert[1]->st[0]; stJ[1] = vert[1]->st[1];
+			stK[0] = vert[2]->st[0]; stK[1] = vert[2]->st[1];
+
+			//   - solve linear equations:
+			//     - (x, y) := xyz . (texX, texY)
+			//     - st[i] = texMat[i][0]*x + texMat[i][1]*y + texMat[i][2]
+			//       (for three vertices)
+			D = Det3x3(
+				xy1I[0], xy1I[1], 1,
+				xy1J[0], xy1J[1], 1,
+				xy1K[0], xy1K[1], 1
+			);
+			if(D != 0)
+			{
+				for(i = 0; i < 2; ++i)
+				{
+					D0 = Det3x3(
+						stI[i], xy1I[1], 1,
+						stJ[i], xy1J[1], 1,
+						stK[i], xy1K[1], 1
+					);
+					D1 = Det3x3(
+						xy1I[0], stI[i], 1,
+						xy1J[0], stJ[i], 1,
+						xy1K[0], stK[i], 1
+					);
+					D2 = Det3x3(
+						xy1I[0], xy1I[1], stI[i],
+						xy1J[0], xy1J[1], stJ[i],
+						xy1K[0], xy1K[1], stK[i]
+					);
+					VectorSet(buildSide->texMat[i], D0 / D, D1 / D, D2 / D);
+					valid = 1;
+				}
+			}
+			else
+				fprintf(stderr, "degenerate triangle found when solving texMat equations for\n(%f %f %f) (%f %f %f) (%f %f %f)\n( %f %f %f )\n( %f %f %f ) -> ( %f %f )\n( %f %f %f ) -> ( %f %f )\n( %f %f %f ) -> ( %f %f )\n",
+					buildPlane->normal[0], buildPlane->normal[1], buildPlane->normal[2],
+					vert[0]->normal[0], vert[0]->normal[1], vert[0]->normal[2],
+					texX[0], texX[1], texX[2], texY[0], texY[1], texY[2],
+					vert[0]->xyz[0], vert[0]->xyz[1], vert[0]->xyz[2], xy1I[0], xy1I[1],
+					vert[1]->xyz[0], vert[1]->xyz[1], vert[1]->xyz[2], xy1J[0], xy1J[1],
+					vert[2]->xyz[0], vert[2]->xyz[1], vert[2]->xyz[2], xy1K[0], xy1K[1]
+					);
+		}
+		else
+			if(strncmp(buildSide->shaderInfo->shader, "textures/common/", 16))
+				fprintf(stderr, "no matching triangle for brushside using %s (hopefully nobody can see this side anyway)\n", buildSide->shaderInfo->shader);
 		
 		/* get texture name */
 		if( !Q_strncasecmp( buildSide->shaderInfo->shader, "textures/", 9 ) )
@@ -130,14 +313,21 @@
 		
 		/* print brush side */
 		/* ( 640 24 -224 ) ( 448 24 -224 ) ( 448 -232 -224 ) common/caulk 0 48 0 0.500000 0.500000 0 0 0 */
-		fprintf( f, "\t\t( %.3f %.3f %.3f ) ( %.3f %.3f %.3f ) ( %.3f %.3f %.3f ) %s 0 0 0 0.5 0.5 0 0 0\n",
+		fprintf( f, "\t\t( %.3f %.3f %.3f ) ( %.3f %.3f %.3f ) ( %.3f %.3f %.3f ) ( ( %.8f %.8f %.8f ) ( %.8f %.8f %.8f ) ) %s %d 0 0\n",
 			pts[ 0 ][ 0 ], pts[ 0 ][ 1 ], pts[ 0 ][ 2 ],
 			pts[ 1 ][ 0 ], pts[ 1 ][ 1 ], pts[ 1 ][ 2 ],
 			pts[ 2 ][ 0 ], pts[ 2 ][ 1 ], pts[ 2 ][ 2 ],
-			texture );
+			buildSide->texMat[0][0], buildSide->texMat[0][1], buildSide->texMat[0][2],
+			buildSide->texMat[1][0], buildSide->texMat[1][1], buildSide->texMat[1][2],
+			texture,
+			// DEBUG: valid ? 0 : C_DETAIL
+			0
+			);
+		// TODO write brush primitives format here
 	}
 	
 	/* end brush */
+	fprintf( f, "\t}\n" );
 	fprintf( f, "\t}\n\n" );
 }
 
Index: tools/quake3/q3map2/main.c
===================================================================
--- tools/quake3/q3map2/main.c.orig	2008-09-06 15:32:05.000000000 +0200
+++ tools/quake3/q3map2/main.c	2008-09-06 15:32:11.000000000 +0200
@@ -541,6 +541,18 @@
 					Sys_Printf( "Unknown conversion format \"%s\". Defaulting to ASE.\n", argv[ i ] );
 			}
  		}
+		else if( !strcmp( argv[ i ],  "-ne" ) )
+ 		{
+			normalEpsilon = atof( argv[ i + 1 ] );
+ 			i++;
+			Sys_Printf( "Normal epsilon set to %f\n", normalEpsilon );
+ 		}
+		else if( !strcmp( argv[ i ],  "-de" ) )
+ 		{
+			distanceEpsilon = atof( argv[ i + 1 ] );
+ 			i++;
+			Sys_Printf( "Distance epsilon set to %f\n", distanceEpsilon );
+ 		}
 	}
 	
 	/* clean up map name */
Index: tools/quake3/q3map2/model.c
===================================================================
--- tools/quake3/q3map2/model.c.orig	2008-09-06 15:32:05.000000000 +0200
+++ tools/quake3/q3map2/model.c	2008-09-06 15:32:12.000000000 +0200
@@ -222,6 +222,8 @@
 	byte				*color;
 	picoIndex_t			*indexes;
 	remap_t				*rm, *glob;
+	double				normalEpsilon_save;
+	double				distanceEpsilon_save;
 	
 	
 	/* get model */
@@ -398,9 +400,8 @@
 		/* ydnar: giant hack land: generate clipping brushes for model triangles */
 		if( si->clipModel || (spawnFlags & 2) )	/* 2nd bit */
 		{
-			vec3_t		points[ 3 ], backs[ 3 ];
+			vec3_t		points[ 4 ], backs[ 3 ];
 			vec4_t		plane, reverse, pa, pb, pc;
-			vec3_t		nadir;
 			
 			
 			/* temp hack */
@@ -437,90 +438,141 @@
 					/* note: this doesn't work as well as simply using the plane of the triangle, below */
 					for( k = 0; k < 3; k++ )
 					{
-						if( fabs( dv->normal[ k ] ) > fabs( dv->normal[ (k + 1) % 3 ] ) &&
-							fabs( dv->normal[ k ] ) > fabs( dv->normal[ (k + 2) % 3 ] ) )
+						if( fabs( dv->normal[ k ] ) >= fabs( dv->normal[ (k + 1) % 3 ] ) &&
+							fabs( dv->normal[ k ] ) >= fabs( dv->normal[ (k + 2) % 3 ] ) )
 						{
 							backs[ j ][ k ] += dv->normal[ k ] < 0.0f ? 64.0f : -64.0f;
 							break;
 						}
 					}
 				}
+
+				VectorCopy( points[0], points[3] ); // for cyclic usage
 				
 				/* make plane for triangle */
+				// div0: add some extra spawnflags:
+				//   0: snap normals to axial planes for extrusion
+				//   8: extrude with the original normals
+				//  16: extrude only with up/down normals (ideal for terrain)
+				//  24: extrude by distance zero (may need engine changes)
 				if( PlaneFromPoints( plane, points[ 0 ], points[ 1 ], points[ 2 ] ) )
 				{
+					vec3_t bestNormal;
+					float backPlaneDistance = 2;
+
+					if(spawnFlags & 8) // use a DOWN normal
+					{
+						if(spawnFlags & 16)
+						{
+							// 24: normal as is, and zero width (broken)
+							VectorCopy(plane, bestNormal);
+						}
+						else
+						{
+							// 8: normal as is
+							VectorCopy(plane, bestNormal);
+						}
+					}
+					else
+					{
+						if(spawnFlags & 16)
+						{
+							// 16: UP/DOWN normal
+							VectorSet(bestNormal, 0, 0, (plane[2] >= 0 ? 1 : -1));
+						}
+						else
+						{
+							// 0: axial normal
+							if(fabs(plane[0]) > fabs(plane[1])) // x>y
+								if(fabs(plane[1]) > fabs(plane[2])) // x>y, y>z
+									VectorSet(bestNormal, (plane[0] >= 0 ? 1 : -1), 0, 0);
+								else // x>y, z>=y
+									if(fabs(plane[0]) > fabs(plane[2])) // x>z, z>=y
+										VectorSet(bestNormal, (plane[0] >= 0 ? 1 : -1), 0, 0);
+									else // z>=x, x>y
+										VectorSet(bestNormal, 0, 0, (plane[2] >= 0 ? 1 : -1));
+							else // y>=x
+								if(fabs(plane[1]) > fabs(plane[2])) // y>z, y>=x
+									VectorSet(bestNormal, 0, (plane[1] >= 0 ? 1 : -1), 0);
+								else // z>=y, y>=x
+									VectorSet(bestNormal, 0, 0, (plane[2] >= 0 ? 1 : -1));
+						}
+					}
+
+					/* build a brush */
+					buildBrush = AllocBrush( 48 );
+					buildBrush->entityNum = mapEntityNum;
+					buildBrush->original = buildBrush;
+					buildBrush->contentShader = si;
+					buildBrush->compileFlags = si->compileFlags;
+					buildBrush->contentFlags = si->contentFlags;
+					normalEpsilon_save = normalEpsilon;
+					distanceEpsilon_save = distanceEpsilon;
+					if(si->compileFlags & C_STRUCTURAL) // allow forced structural brushes here
+					{
+						buildBrush->detail = qfalse;
+
+						// only allow EXACT matches when snapping for these (this is mostly for caulk brushes inside a model)
+						if(normalEpsilon > 0)
+							normalEpsilon = 0;
+						if(distanceEpsilon > 0)
+							distanceEpsilon = 0;
+					}
+					else
+						buildBrush->detail = qtrue;
+
 					/* regenerate back points */
 					for( j = 0; j < 3; j++ )
 					{
 						/* get vertex */
 						dv = &ds->verts[ ds->indexes[ i + j ] ];
-						
-						/* copy xyz */
-						VectorCopy( dv->xyz, backs[ j ] );
-						
-						/* find nearest axial to plane normal and push back points opposite */
-						for( k = 0; k < 3; k++ )
-						{
-							if( fabs( plane[ k ] ) > fabs( plane[ (k + 1) % 3 ] ) &&
-								fabs( plane[ k ] ) > fabs( plane[ (k + 2) % 3 ] ) )
-							{
-								backs[ j ][ k ] += plane[ k ] < 0.0f ? 64.0f : -64.0f;
-								break;
-							}
-						}
+
+						// shift by some units
+						VectorMA(dv->xyz, -64.0f, bestNormal, backs[j]); // 64 prevents roundoff errors a bit
 					}
-					
+
 					/* make back plane */
 					VectorScale( plane, -1.0f, reverse );
-					reverse[ 3 ] = -(plane[ 3 ] - 1);
-					
-					/* make back pyramid point */
-					VectorCopy( points[ 0 ], nadir );
-					VectorAdd( nadir, points[ 1 ], nadir );
-					VectorAdd( nadir, points[ 2 ], nadir );
-					VectorScale( nadir, 0.3333333333333f, nadir );
-					VectorMA( nadir, -2.0f, plane, nadir );
-					
-					/* make 3 more planes */
-					//%	if( PlaneFromPoints( pa, points[ 2 ], points[ 1 ], nadir ) &&
-					//%		PlaneFromPoints( pb, points[ 1 ], points[ 0 ], nadir ) &&
-					//%		PlaneFromPoints( pc, points[ 0 ], points[ 2 ], nadir ) )
+					reverse[ 3 ] = -plane[ 3 ];
+					if((spawnFlags & 24) != 24)
+						reverse[3] += DotProduct(bestNormal, plane) * backPlaneDistance;
+					// that's at least sqrt(1/3) backPlaneDistance, unless in DOWN mode; in DOWN mode, we are screwed anyway if we encounter a plane that's perpendicular to the xy plane)
+
 					if( PlaneFromPoints( pa, points[ 2 ], points[ 1 ], backs[ 1 ] ) &&
-						PlaneFromPoints( pb, points[ 1 ], points[ 0 ], backs[ 0 ] ) &&
-						PlaneFromPoints( pc, points[ 0 ], points[ 2 ], backs[ 2 ] ) )
+							PlaneFromPoints( pb, points[ 1 ], points[ 0 ], backs[ 0 ] ) &&
+							PlaneFromPoints( pc, points[ 0 ], points[ 2 ], backs[ 2 ] ) )
 					{
-						/* build a brush */
-						buildBrush = AllocBrush( 48 );
-						
-						buildBrush->entityNum = mapEntityNum;
-						buildBrush->original = buildBrush;
-						buildBrush->contentShader = si;
-						buildBrush->compileFlags = si->compileFlags;
-						buildBrush->contentFlags = si->contentFlags;
-						buildBrush->detail = qtrue;
-						
 						/* set up brush sides */
 						buildBrush->numsides = 5;
 						for( j = 0; j < buildBrush->numsides; j++ )
 							buildBrush->sides[ j ].shaderInfo = si;
+
 						buildBrush->sides[ 0 ].planenum = FindFloatPlane( plane, plane[ 3 ], 3, points );
-						buildBrush->sides[ 1 ].planenum = FindFloatPlane( pa, pa[ 3 ], 1, &points[ 2 ] );
-						buildBrush->sides[ 2 ].planenum = FindFloatPlane( pb, pb[ 3 ], 1, &points[ 1 ] );
-						buildBrush->sides[ 3 ].planenum = FindFloatPlane( pc, pc[ 3 ], 1, &points[ 0 ] );
-						buildBrush->sides[ 4 ].planenum = FindFloatPlane( reverse, reverse[ 3 ], 3, points );
-						
-						/* add to entity */
-						if( CreateBrushWindings( buildBrush ) )
-						{
-							AddBrushBevels();
-							//%	EmitBrushes( buildBrush, NULL, NULL );
-							buildBrush->next = entities[ mapEntityNum ].brushes;
-							entities[ mapEntityNum ].brushes = buildBrush;
-							entities[ mapEntityNum ].numBrushes++;
-						}
-						else
-							free( buildBrush );
+						buildBrush->sides[ 1 ].planenum = FindFloatPlane( pa, pa[ 3 ], 2, &points[ 1 ] ); // pa contains points[1] and points[2]
+						buildBrush->sides[ 2 ].planenum = FindFloatPlane( pb, pb[ 3 ], 2, &points[ 0 ] ); // pb contains points[0] and points[1]
+						buildBrush->sides[ 3 ].planenum = FindFloatPlane( pc, pc[ 3 ], 2, &points[ 2 ] ); // pc contains points[2] and points[0] (copied to points[3]
+						buildBrush->sides[ 4 ].planenum = FindFloatPlane( reverse, reverse[ 3 ], 3, backs );
+					}
+					else
+					{
+						free(buildBrush);
+						continue;
+					}
+
+					normalEpsilon = normalEpsilon_save;
+					distanceEpsilon = distanceEpsilon_save;
+
+					/* add to entity */
+					if( CreateBrushWindings( buildBrush ) )
+					{
+						AddBrushBevels();
+						//%	EmitBrushes( buildBrush, NULL, NULL );
+						buildBrush->next = entities[ mapEntityNum ].brushes;
+						entities[ mapEntityNum ].brushes = buildBrush;
+						entities[ mapEntityNum ].numBrushes++;
 					}
+					else
+						free( buildBrush );
 				}
 			}
 		}
Index: tools/quake3/q3map2/map.c
===================================================================
--- tools/quake3/q3map2/map.c.orig	2008-09-06 15:32:04.000000000 +0200
+++ tools/quake3/q3map2/map.c	2008-09-06 15:32:12.000000000 +0200
@@ -184,7 +184,7 @@
 snaps a plane to normal/distance epsilons
 */
 
-void SnapPlane( vec3_t normal, vec_t *dist )
+void SnapPlane( vec3_t normal, vec_t *dist, vec3_t center )
 {
 // SnapPlane disabled by LordHavoc because it often messes up collision
 // brushes made from triangles of embedded models, and it has little effect
@@ -193,7 +193,13 @@
   SnapPlane reenabled by namespace because of multiple reports of
   q3map2-crashes which were triggered by this patch.
 */
+	// div0: ensure the point "center" stays on the plane (actually, this
+	// rotates the plane around the point center).
+	// if center lies on the plane, it is guaranteed to stay on the plane by
+	// this fix.
+	vec_t centerDist = DotProduct(normal, center);
 	SnapNormal( normal );
+	*dist += (DotProduct(normal, center) - centerDist);
 
 	if( fabs( *dist - Q_rint( *dist ) ) < distanceEpsilon )
 		*dist = Q_rint( *dist );
@@ -207,7 +213,7 @@
 must be within an epsilon distance of the plane
 */
 
-int FindFloatPlane( vec3_t normal, vec_t dist, int numPoints, vec3_t *points )
+int FindFloatPlane( vec3_t normal, vec_t dist, int numPoints, vec3_t *points ) // NOTE: this has a side effect on the normal. Good or bad?
 
 #ifdef USE_HASHING
 
@@ -215,10 +221,14 @@
 	int		i, j, hash, h;
 	plane_t	*p;
 	vec_t	d;
-	
+	vec3_t centerofweight;
+
+	VectorClear(centerofweight);
+	for(i = 0; i < numPoints; ++i)
+		VectorMA(centerofweight, 1.0 / numPoints, points[i], centerofweight);
 	
 	/* hash the plane */
-	SnapPlane( normal, &dist );
+	SnapPlane( normal, &dist, centerofweight );
 	hash = (PLANE_HASHES - 1) & (int) fabs( dist );
 	
 	/* search the border bins as well */
@@ -259,7 +269,13 @@
 	plane_t	*p;
 	
 
-	SnapPlane( normal, &dist );
+	vec3_t centerofweight;
+
+	VectorClear(centerofweight);
+	for(i = 0; i < numPoints; ++i)
+		VectorMA(centerofweight, 1.0 / numPoints, points[i], centerofweight);
+
+	SnapPlane( normal, &dist, centerofweight );
 	for( i = 0, p = mapplanes; i < nummapplanes; i++, p++ )
 	{
 		if( PlaneEqual( p, normal, dist ) )
Index: tools/quake3/q3map2/shaders.c
===================================================================
--- tools/quake3/q3map2/shaders.c.orig	2008-09-06 15:32:04.000000000 +0200
+++ tools/quake3/q3map2/shaders.c	2008-09-06 15:32:13.000000000 +0200
@@ -794,8 +794,14 @@
 	}
 	
 	if( VectorLength( si->color ) <= 0.0f )
+	{
 		ColorNormalize( color, si->color );
-	VectorScale( color, (1.0f / count), si->averageColor );
+		VectorScale( color, (1.0f / count), si->averageColor );
+	}
+	else
+	{
+		VectorCopy( si->color, si->averageColor );
+	}
 }
 
 
Index: tools/quake3/q3map2/light_ydnar.c
===================================================================
--- tools/quake3/q3map2/light_ydnar.c.orig	2008-09-06 15:32:04.000000000 +0200
+++ tools/quake3/q3map2/light_ydnar.c	2008-09-06 15:32:14.000000000 +0200
@@ -1767,6 +1767,8 @@
 	float				tests[ 4 ][ 2 ] = { { 0.0f, 0 }, { 1, 0 }, { 0, 1 }, { 1, 1 } };
 	trace_t				trace;
 	float				stackLightLuxels[ STACK_LL_SIZE ];
+	vec3_t				flood;
+	float				*floodlight;
 	
 	
 	/* bail if this number exceeds the number of raw lightmaps */
@@ -2223,6 +2225,78 @@
 	FreeTraceLights( &trace );
 	
 	/*	-----------------------------------------------------------------
+		floodlight pass
+		----------------------------------------------------------------- */
+
+	if( floodlighty )
+	{
+		/* walk lightmaps */
+		for( lightmapNum = 0; lightmapNum < MAX_LIGHTMAPS; lightmapNum++ )
+		{
+			/* early out */
+			if( lm->superLuxels[ lightmapNum ] == NULL )
+				continue;
+
+			/* apply floodlight to each luxel */
+			for( y = 0; y < lm->sh; y++ )
+			{
+				for( x = 0; x < lm->sw; x++ )
+				{
+					/* get cluster */
+					cluster	= SUPER_CLUSTER( x, y );
+					//%	if( *cluster < 0 )
+					//%		continue;
+
+					/* get particulars */
+					luxel = SUPER_LUXEL( lightmapNum, x, y );
+					floodlight = SUPER_FLOODLIGHT( x, y );
+
+					flood[0]=floodlightRGB[0]*floodlightIntensity;
+					flood[1]=floodlightRGB[1]*floodlightIntensity;
+					flood[2]=floodlightRGB[2]*floodlightIntensity;
+
+					/* scale light value */
+					VectorScale( flood, *floodlight, flood );
+					luxel[0]+=flood[0];
+					luxel[1]+=flood[1];
+					luxel[2]+=flood[2];
+
+					if (luxel[3]==0) luxel[3]=1;
+				}
+			}
+		}
+	}
+
+	if (debugnormals)
+	{
+		for( lightmapNum = 0; lightmapNum < MAX_LIGHTMAPS; lightmapNum++ )
+		{
+			/* early out */
+			if( lm->superLuxels[ lightmapNum ] == NULL )
+				continue;
+
+			for( y = 0; y < lm->sh; y++ )
+			{
+				for( x = 0; x < lm->sw; x++ )
+				{
+					/* get cluster */
+					cluster	= SUPER_CLUSTER( x, y );
+					//%	if( *cluster < 0 )
+					//%		continue;
+
+					/* get particulars */
+					luxel = SUPER_LUXEL( lightmapNum, x, y );
+					normal = SUPER_NORMAL (  x, y );
+
+					luxel[0]=(normal[0]*127)+127;
+					luxel[1]=(normal[1]*127)+127;
+					luxel[2]=(normal[2]*127)+127;
+				}
+			}
+		}
+	}
+
+	/*	-----------------------------------------------------------------
 		dirt pass
 		----------------------------------------------------------------- */
 	
@@ -3587,7 +3661,320 @@
 	CreateTraceLightsForBounds( mins, maxs, normal, info->numSurfaceClusters, &surfaceClusters[ info->firstSurfaceCluster ], LIGHT_SURFACES, trace );
 }
 
+/////////////////////////////////////////////////////////////
+
+#define FLOODLIGHT_CONE_ANGLE			88	/* degrees */
+#define FLOODLIGHT_NUM_ANGLE_STEPS		16
+#define FLOODLIGHT_NUM_ELEVATION_STEPS	4
+#define FLOODLIGHT_NUM_VECTORS			(FLOODLIGHT_NUM_ANGLE_STEPS * FLOODLIGHT_NUM_ELEVATION_STEPS)
+
+static vec3_t	floodVectors[ FLOODLIGHT_NUM_VECTORS ];
+static int		numFloodVectors = 0;
+
+void SetupFloodLight( void )
+{
+	int		i, j;
+	float	angle, elevation, angleStep, elevationStep;
+	const char	*value;
+	double v1,v2,v3,v4,v5;
+
+	/* note it */
+	Sys_FPrintf( SYS_VRB, "--- SetupFloodLight ---\n" );
+
+	/* calculate angular steps */
+	angleStep = DEG2RAD( 360.0f / FLOODLIGHT_NUM_ANGLE_STEPS );
+	elevationStep = DEG2RAD( FLOODLIGHT_CONE_ANGLE / FLOODLIGHT_NUM_ELEVATION_STEPS );
+
+	/* iterate angle */
+	angle = 0.0f;
+	for( i = 0, angle = 0.0f; i < FLOODLIGHT_NUM_ANGLE_STEPS; i++, angle += angleStep )
+	{
+		/* iterate elevation */
+		for( j = 0, elevation = elevationStep * 0.5f; j < FLOODLIGHT_NUM_ELEVATION_STEPS; j++, elevation += elevationStep )
+		{
+			floodVectors[ numFloodVectors ][ 0 ] = sin( elevation ) * cos( angle );
+			floodVectors[ numFloodVectors ][ 1 ] = sin( elevation ) * sin( angle );
+			floodVectors[ numFloodVectors ][ 2 ] = cos( elevation );
+			numFloodVectors++;
+		}
+	}
+
+	/* emit some statistics */
+	Sys_FPrintf( SYS_VRB, "%9d numFloodVectors\n", numFloodVectors );
 
+      /* floodlight */
+	value = ValueForKey( &entities[ 0 ], "_floodlight" );
 
+	if( value[ 0 ] != '\0' )
+	{
+		v1=v2=v3=0;
+		v4=floodlightDistance;
+		v5=floodlightIntensity;
+
+		sscanf( value, "%lf %lf %lf %lf %lf", &v1, &v2, &v3, &v4, &v5);
+
+		floodlightRGB[0]=v1;
+		floodlightRGB[1]=v2;
+		floodlightRGB[2]=v3;
+
+		if (VectorLength(floodlightRGB)==0)
+		{
+			VectorSet(floodlightRGB,240,240,255);
+		}
 
+		if (v4<1) v4=1024;
+		if (v5<1) v5=128;
+
+		floodlightDistance=v4;
+		floodlightIntensity=v5;
+
+		floodlighty = qtrue;
+		Sys_Printf( "FloodLighting enabled via worldspawn _floodlight key.\n" );
+	}
+	else
+	{
+		VectorSet(floodlightRGB,240,240,255);
+		//floodlighty = qtrue;
+		//Sys_Printf( "FloodLighting enabled via worldspawn _floodlight key.\n" );
+	}
+	VectorNormalize(floodlightRGB,floodlightRGB);
+}
+
+//27 - lighttracer style ambient occlusion light hack.
+//Kudos to the dirtmapping author for most of this source.
+void FloodLightRawLightmap( int rawLightmapNum )
+{
+	int					i, x, y, sx, sy, *cluster;
+	float				*origin, *normal, *floodlight, *floodlight2, average, samples;
+	rawLightmap_t		*lm;
+	surfaceInfo_t		*info;
+	trace_t				trace;
+
+	/* bail if this number exceeds the number of raw lightmaps */
+	if( rawLightmapNum >= numRawLightmaps )
+		return;
+
+	/* get lightmap */
+	lm = &rawLightmaps[ rawLightmapNum ];
+
+	memset(&trace,0,sizeof(trace_t));
+	/* setup trace */
+	trace.testOcclusion = qtrue;
+	trace.forceSunlight = qfalse;
+	trace.twoSided = qtrue;
+	trace.recvShadows = lm->recvShadows;
+	trace.numSurfaces = lm->numLightSurfaces;
+	trace.surfaces = &lightSurfaces[ lm->firstLightSurface ];
+	trace.inhibitRadius = DEFAULT_INHIBIT_RADIUS;
+	trace.testAll = qfalse;
+	trace.distance = 1024;
+
+	/* twosided lighting (may or may not be a good idea for lightmapped stuff) */
+	//trace.twoSided = qfalse;
+	for( i = 0; i < trace.numSurfaces; i++ )
+	{
+		/* get surface */
+		info = &surfaceInfos[ trace.surfaces[ i ] ];
+
+		/* check twosidedness */
+		if( info->si->twoSided )
+		{
+			trace.twoSided = qtrue;
+			break;
+		}
+	}
+
+	/* gather dirt */
+	for( y = 0; y < lm->sh; y++ )
+	{
+		for( x = 0; x < lm->sw; x++ )
+		{
+			/* get luxel */
+			cluster = SUPER_CLUSTER( x, y );
+			origin = SUPER_ORIGIN( x, y );
+			normal = SUPER_NORMAL( x, y );
+			floodlight = SUPER_FLOODLIGHT( x, y );
+
+			/* set default dirt */
+			*floodlight = 0.0f;
+
+			/* only look at mapped luxels */
+			if( *cluster < 0 )
+				continue;
+
+			/* copy to trace */
+			trace.cluster = *cluster;
+			VectorCopy( origin, trace.origin );
+			VectorCopy( normal, trace.normal );
+
+
+
+			/* get dirt */
+			*floodlight = FloodLightForSample( &trace );
+		}
+	}
+
+	/* testing no filtering */
+	return;
+
+	/* filter "dirt" */
+	for( y = 0; y < lm->sh; y++ )
+	{
+		for( x = 0; x < lm->sw; x++ )
+		{
+			/* get luxel */
+			cluster = SUPER_CLUSTER( x, y );
+			floodlight = SUPER_FLOODLIGHT( x, y );
+
+			/* filter dirt by adjacency to unmapped luxels */
+			average = *floodlight;
+			samples = 1.0f;
+			for( sy = (y - 1); sy <= (y + 1); sy++ )
+			{
+				if( sy < 0 || sy >= lm->sh )
+					continue;
+
+				for( sx = (x - 1); sx <= (x + 1); sx++ )
+				{
+					if( sx < 0 || sx >= lm->sw || (sx == x && sy == y) )
+						continue;
+
+					/* get neighboring luxel */
+					cluster = SUPER_CLUSTER( sx, sy );
+					floodlight2 = SUPER_FLOODLIGHT( sx, sy );
+					if( *cluster < 0 || *floodlight2 <= 0.0f )
+						continue;
+
+					/* add it */
+					average += *floodlight2;
+					samples += 1.0f;
+				}
+
+				/* bail */
+				if( samples <= 0.0f )
+					break;
+			}
+
+			/* bail */
+			if( samples <= 0.0f )
+				continue;
+
+			/* scale dirt */
+			*floodlight = average / samples;
+		}
+	}
+}
+
+/*
+FloodLightForSample()
+calculates floodlight value for a given sample
+once again, kudos to the dirtmapping coder
+*/
+float FloodLightForSample( trace_t *trace )
+{
+	int		i;
+	float 	d;
+	float 	contribution;
+	int 	sub = 0;
+	float	gatherLight, outLight;
+	vec3_t	normal, worldUp, myUp, myRt, direction, displacement;
+	float 	dd;
+	int 	vecs = 0;
+
+	gatherLight=0;
+	/* dummy check */
+	//if( !dirty )
+	//	return 1.0f;
+	if( trace == NULL || trace->cluster < 0 )
+		return 0.0f;
+
+
+	/* setup */
+	dd = floodlightDistance;
+	VectorCopy( trace->normal, normal );
+
+	/* check if the normal is aligned to the world-up */
+	if( normal[ 0 ] == 0.0f && normal[ 1 ] == 0.0f )
+	{
+		if( normal[ 2 ] == 1.0f )
+		{
+			VectorSet( myRt, 1.0f, 0.0f, 0.0f );
+			VectorSet( myUp, 0.0f, 1.0f, 0.0f );
+		}
+		else if( normal[ 2 ] == -1.0f )
+		{
+			VectorSet( myRt, -1.0f, 0.0f, 0.0f );
+			VectorSet( myUp,  0.0f, 1.0f, 0.0f );
+		}
+	}
+	else
+	{
+		VectorSet( worldUp, 0.0f, 0.0f, 1.0f );
+		CrossProduct( normal, worldUp, myRt );
+		VectorNormalize( myRt, myRt );
+		CrossProduct( myRt, normal, myUp );
+		VectorNormalize( myUp, myUp );
+	}
+
+	/* iterate through ordered vectors */
+	for( i = 0; i < numFloodVectors; i++ )
+	{
+		if (floodlight_lowquality==qtrue)
+        {
+			if (rand()%10 != 0 ) continue;
+		}
+
+		vecs++;
+
+		/* transform vector into tangent space */
+		direction[ 0 ] = myRt[ 0 ] * floodVectors[ i ][ 0 ] + myUp[ 0 ] * floodVectors[ i ][ 1 ] + normal[ 0 ] * floodVectors[ i ][ 2 ];
+		direction[ 1 ] = myRt[ 1 ] * floodVectors[ i ][ 0 ] + myUp[ 1 ] * floodVectors[ i ][ 1 ] + normal[ 1 ] * floodVectors[ i ][ 2 ];
+		direction[ 2 ] = myRt[ 2 ] * floodVectors[ i ][ 0 ] + myUp[ 2 ] * floodVectors[ i ][ 1 ] + normal[ 2 ] * floodVectors[ i ][ 2 ];
+
+		/* set endpoint */
+		VectorMA( trace->origin, dd, direction, trace->end );
+
+		//VectorMA( trace->origin, 1, direction, trace->origin );
+
+		SetupTrace( trace );
+		/* trace */
+	  	TraceLine( trace );
+		contribution=1;
+
+		if (trace->compileFlags & C_SKY )
+		{
+			contribution=1.0f;
+		}
+		else if ( trace->opaque )
+		{
+			VectorSubtract( trace->hit, trace->origin, displacement );
+			d=VectorLength( displacement );
+
+			// d=trace->distance;
+			//if (d>256) gatherDirt+=1;
+			contribution=d/dd;
+			if (contribution>1) contribution=1.0f;
+
+			//gatherDirt += 1.0f - ooDepth * VectorLength( displacement );
+		}
+
+		gatherLight+=contribution;
+	}
+
+	/* early out */
+	if( gatherLight <= 0.0f )
+		return 0.0f;
+
+	sub=vecs;
+
+	if (sub<1) sub=1;
+	gatherLight/=(sub);
+
+	outLight=gatherLight;
+	if( outLight > 1.0f )
+		outLight = 1.0f;
+
+	/* return to sender */
+	return outLight;
+}
 
Index: tools/quake3/q3map2/light.c
===================================================================
--- tools/quake3/q3map2/light.c.orig	2008-09-06 15:32:04.000000000 +0200
+++ tools/quake3/q3map2/light.c	2008-09-06 15:32:14.000000000 +0200
@@ -1378,6 +1378,56 @@
 			break;
 	}
 	
+	/////// Floodlighting for point //////////////////
+	//do our floodlight ambient occlusion loop, and add a single contribution based on the brightest dir
+	if (floodlighty)
+	{
+		int q;
+		float addSize,f;
+		vec3_t col,dir;
+		col[0]=col[1]=col[2]=floodlightIntensity;
+		dir[0]=dir[1]=0;
+		dir[2]=1;
+
+		trace.testOcclusion = qtrue;
+		trace.forceSunlight = qfalse;
+		trace.inhibitRadius = DEFAULT_INHIBIT_RADIUS;
+		trace.testAll = qtrue;
+
+		for (q=0;q<2;q++)
+		{
+			if (q==0) //upper hemisphere
+			{
+				trace.normal[0]=0;
+				trace.normal[1]=0;
+				trace.normal[2]=1;
+			}
+			else //lower hemisphere
+			{
+				trace.normal[0]=0;
+				trace.normal[1]=0;
+				trace.normal[2]=-1;
+			}
+
+			f = FloodLightForSample(&trace);
+
+			contributions[ numCon ].color[0]=col[0]*f;
+			contributions[ numCon ].color[1]=col[1]*f;
+			contributions[ numCon ].color[2]=col[2]*f;
+
+			contributions[ numCon ].dir[0]=dir[0];
+			contributions[ numCon ].dir[1]=dir[1];
+			contributions[ numCon ].dir[2]=dir[2];
+
+			contributions[ numCon ].style = 0;
+			numCon++;
+			/* push average direction around */
+			addSize = VectorLength( col );
+			VectorMA( gp->dir, addSize, dir, gp->dir );
+		}
+	}
+	/////////////////////
+
 	/* normalize to get primary light direction */
 	VectorNormalize( gp->dir, gp->dir );
 	
@@ -1661,6 +1711,12 @@
 		RunThreadsOnIndividual( numRawLightmaps, qtrue, DirtyRawLightmap );
 	}
 	
+	/* floodlight them up */
+	if( floodlighty )
+	{
+		Sys_Printf( "--- FloodlightRawLightmap ---\n" );
+		RunThreadsOnIndividual( numRawLightmaps, qtrue, FloodLightRawLightmap );
+	}
 
 	/* ydnar: set up light envelopes */
 	SetupEnvelopes( qfalse, fast );
@@ -1703,6 +1759,7 @@
 		/* flag bouncing */
 		bouncing = qtrue;
 		VectorClear( ambientColor );
+		floodlighty = false;
 		
 		/* generate diffuse lights */
 		RadFreeLights();
@@ -2191,6 +2248,21 @@
 			cpmaHack = qtrue;
 			Sys_Printf( "Enabling Challenge Pro Mode Asstacular Vertex Lighting Mode (tm)\n" );
 		}
+		else if( !strcmp( argv[ i ], "-floodlight" ) )
+		{
+			floodlighty = qtrue;
+			Sys_Printf( "FloodLighting enabled\n" );
+		}
+		else if( !strcmp( argv[ i ], "-debugnormals" ) )
+		{
+			debugnormals = qtrue;
+			Sys_Printf( "DebugNormals enabled\n" );
+		}
+		else if( !strcmp( argv[ i ], "-lowquality" ) )
+		{
+			floodlight_lowquality = qtrue;
+			Sys_Printf( "Low Quality FloodLighting enabled\n" );
+		}
 		
 		/* r7: dirtmapping */
 		else if( !strcmp( argv[ i ], "-dirty" ) )
@@ -2279,6 +2351,7 @@
 	/* ydnar: set up optimization */
 	SetupBrushes();
 	SetupDirt();
+	SetupFloodLight();
 	SetupSurfaceLightmaps();
 	
 	/* initialize the surface facet tracing */
Index: tools/quake3/q3map2/lightmaps_ydnar.c
===================================================================
--- tools/quake3/q3map2/lightmaps_ydnar.c.orig	2008-09-06 15:32:04.000000000 +0200
+++ tools/quake3/q3map2/lightmaps_ydnar.c	2008-09-06 15:32:14.000000000 +0200
@@ -414,6 +414,12 @@
 		lm->superNormals = safe_malloc( size );
 	memset( lm->superNormals, 0, size );
 	
+ 	/* allocate floodlight map storage */
+	size = lm->sw * lm->sh * SUPER_FLOODLIGHT_SIZE * sizeof( float );
+	if( lm->superFloodLight == NULL )
+		lm->superFloodLight = safe_malloc( size );
+	memset( lm->superFloodLight, 0, size );
+
 	/* allocate cluster map storage */
 	size = lm->sw * lm->sh * sizeof( int );
 	if( lm->superClusters == NULL )
Index: tools/quake3/q3map2/q3map2.h
===================================================================
--- tools/quake3/q3map2/q3map2.h.orig	2008-09-06 15:32:04.000000000 +0200
+++ tools/quake3/q3map2/q3map2.h	2008-09-06 15:32:14.000000000 +0200
@@ -266,6 +266,7 @@
 #define SUPER_NORMAL_SIZE		4
 #define SUPER_DELUXEL_SIZE		3
 #define BSP_DELUXEL_SIZE		3
+#define SUPER_FLOODLIGHT_SIZE	1
 
 #define VERTEX_LUXEL( s, v )	(vertexLuxels[ s ] + ((v) * VERTEX_LUXEL_SIZE))
 #define RAD_VERTEX_LUXEL( s, v )(radVertexLuxels[ s ] + ((v) * VERTEX_LUXEL_SIZE))
@@ -278,6 +279,7 @@
 #define SUPER_ORIGIN( x, y )	(lm->superOrigins + ((((y) * lm->sw) + (x)) * SUPER_ORIGIN_SIZE))
 #define SUPER_NORMAL( x, y )	(lm->superNormals + ((((y) * lm->sw) + (x)) * SUPER_NORMAL_SIZE))
 #define SUPER_DIRT( x, y )		(lm->superNormals + ((((y) * lm->sw) + (x)) * SUPER_NORMAL_SIZE) + 3)	/* stash dirtyness in normal[ 3 ] */
+#define SUPER_FLOODLIGHT( x, y )	(lm->superFloodLight + ((((y) * lm->sw) + (x)) * SUPER_FLOODLIGHT_SIZE) )
 
 
 
@@ -1400,6 +1402,7 @@
 	
 	float					*superDeluxels;	/* average light direction */
 	float					*bspDeluxels;
+	float					*superFloodLight;
 }
 rawLightmap_t;
 
@@ -1712,6 +1715,10 @@
 float						DirtForSample( trace_t *trace );
 void						DirtyRawLightmap( int num );
 
+void						SetupFloodLight();
+float						FloodLightForSample( trace_t *trace );
+void						FloodLightRawLightmap( int num );
+
 void						IlluminateRawLightmap( int num );
 void						IlluminateVertexes( int num );
 
@@ -2106,6 +2113,13 @@
 Q_EXTERN float				dirtScale Q_ASSIGN( 1.0f );
 Q_EXTERN float				dirtGain Q_ASSIGN( 1.0f );
 
+Q_EXTERN qboolean			debugnormals Q_ASSIGN( qfalse );
+Q_EXTERN qboolean			floodlighty Q_ASSIGN( qfalse );
+Q_EXTERN qboolean			floodlight_lowquality Q_ASSIGN( qfalse );
+Q_EXTERN vec3_t				floodlightRGB;
+Q_EXTERN float				floodlightIntensity Q_ASSIGN( 512 );
+Q_EXTERN float				floodlightDistance Q_ASSIGN( 1024 );
+
 Q_EXTERN qboolean			dump Q_ASSIGN( qfalse );
 Q_EXTERN qboolean			debug Q_ASSIGN( qfalse );
 Q_EXTERN qboolean			debugUnused Q_ASSIGN( qfalse );
Index: tools/quake3/q3map2/game_ja.h
===================================================================
--- tools/quake3/q3map2/game_ja.h.orig	2008-09-06 15:32:04.000000000 +0200
+++ tools/quake3/q3map2/game_ja.h	2008-09-06 15:32:16.000000000 +0200
@@ -67,6 +67,7 @@
 	qfalse,				/* wolf lighting model? */
 	128,				/* lightmap width/height */
 	1.0f,				/* lightmap gamma */
+	1.0f,				/* lightmap exposure */
 	1.0f,				/* lightmap compensate */
 	"RBSP",				/* bsp file prefix */
 	1,					/* bsp file version */
Index: tools/quake3/q3map2/game_tremulous.h
===================================================================
--- tools/quake3/q3map2/game_tremulous.h.orig	2008-09-06 15:32:04.000000000 +0200
+++ tools/quake3/q3map2/game_tremulous.h	2008-09-06 15:32:16.000000000 +0200
@@ -70,6 +70,7 @@
 	qfalse,				/* wolf lighting model? */
 	128,				/* lightmap width/height */
 	1.0f,				/* lightmap gamma */
+	1.0f,				/* lightmap exposure */
 	1.0f,				/* lightmap compensate */
 	"IBSP",				/* bsp file prefix */
 	46,					/* bsp file version */
Index: tools/quake3/q3map2/game_wolfet.h
===================================================================
--- tools/quake3/q3map2/game_wolfet.h.orig	2008-09-06 15:32:04.000000000 +0200
+++ tools/quake3/q3map2/game_wolfet.h	2008-09-06 15:32:16.000000000 +0200
@@ -66,6 +66,7 @@
 	qtrue,				/* wolf lighting model? */
 	128,				/* lightmap width/height */
 	1.0f,				/* lightmap gamma */
+	1.0f,				/* lightmap exposure */
 	1.0f,				/* lightmap compensate */
 	"IBSP",				/* bsp file prefix */
 	47,					/* bsp file version */
Index: tools/quake3/q3map2/game_wolf.h
===================================================================
--- tools/quake3/q3map2/game_wolf.h.orig	2008-09-06 15:32:04.000000000 +0200
+++ tools/quake3/q3map2/game_wolf.h	2008-09-06 15:32:16.000000000 +0200
@@ -129,6 +129,7 @@
 	qtrue,				/* wolf lighting model? */
 	128,				/* lightmap width/height */
 	1.0f,				/* lightmap gamma */
+	1.0f,				/* lightmap exposure */
 	1.0f,				/* lightmap compensate */
 	"IBSP",				/* bsp file prefix */
 	47,					/* bsp file version */
Index: tools/quake3/q3map2/game_sof2.h
===================================================================
--- tools/quake3/q3map2/game_sof2.h.orig	2008-09-06 15:32:04.000000000 +0200
+++ tools/quake3/q3map2/game_sof2.h	2008-09-06 15:32:16.000000000 +0200
@@ -139,6 +139,7 @@
 	qfalse,					/* wolf lighting model? */
 	128,					/* lightmap width/height */
 	1.0f,					/* lightmap gamma */
+	1.0f,					/* lightmap exposure */
 	1.0f,					/* lightmap compensate */
 	"RBSP",					/* bsp file prefix */
 	1,						/* bsp file version */
Index: tools/quake3/q3map2/game_etut.h
===================================================================
--- tools/quake3/q3map2/game_etut.h.orig	2008-09-06 15:32:04.000000000 +0200
+++ tools/quake3/q3map2/game_etut.h	2008-09-06 15:32:16.000000000 +0200
@@ -148,6 +148,7 @@
 	qfalse,				/* wolf lighting model? */
 	128,				/* lightmap width/height */
 	2.2f,				/* lightmap gamma */
+	1.0f,				/* lightmap exposure */
 	1.0f,				/* lightmap compensate */
 	"IBSP",				/* bsp file prefix */
 	47,					/* bsp file version */
Index: tools/quake3/q3map2/game_jk2.h
===================================================================
--- tools/quake3/q3map2/game_jk2.h.orig	2008-09-06 15:32:04.000000000 +0200
+++ tools/quake3/q3map2/game_jk2.h	2008-09-06 15:32:16.000000000 +0200
@@ -64,6 +64,7 @@
 	qfalse,				/* wolf lighting model? */
 	128,				/* lightmap width/height */
 	1.0f,				/* lightmap gamma */
+	1.0f,				/* lightmap exposure */
 	1.0f,				/* lightmap compensate */
 	"RBSP",				/* bsp file prefix */
 	1,					/* bsp file version */
Index: tools/quake3/q3map2/game_qfusion.h
===================================================================
--- tools/quake3/q3map2/game_qfusion.h.orig	2008-09-06 15:32:04.000000000 +0200
+++ tools/quake3/q3map2/game_qfusion.h	2008-09-06 15:32:16.000000000 +0200
@@ -115,6 +115,7 @@
 	qfalse,				/* wolf lighting model? */
 	512,				/* lightmap width/height */
 	1.0f,				/* lightmap gamma */
+	1.0f,				/* lightmap exposure */
 	1.0f,				/* lightmap compensate */
 	"FBSP",				/* bsp file prefix */
 	1,					/* bsp file version */
Index: tools/quake3/q3map2/game_tenebrae.h
===================================================================
--- tools/quake3/q3map2/game_tenebrae.h.orig	2008-09-06 15:32:04.000000000 +0200
+++ tools/quake3/q3map2/game_tenebrae.h	2008-09-06 15:32:16.000000000 +0200
@@ -112,6 +112,7 @@
 	qfalse,				/* wolf lighting model? */
 	512,				/* lightmap width/height */
 	2.0f,				/* lightmap gamma */
+	1.0f,				/* lightmap exposure */
 	1.0f,				/* lightmap compensate */
 	"IBSP",				/* bsp file prefix */
 	46,					/* bsp file version */
Index: tools/quake3/q3map2/game_quake3.h
===================================================================
--- tools/quake3/q3map2/game_quake3.h.orig	2008-09-06 15:32:04.000000000 +0200
+++ tools/quake3/q3map2/game_quake3.h	2008-09-06 15:32:16.000000000 +0200
@@ -112,6 +112,7 @@
 	qfalse,				/* wolf lighting model? */
 	128,				/* lightmap width/height */
 	1.0f,				/* lightmap gamma */
+	1.0f,				/* lightmap exposure */
 	1.0f,				/* lightmap compensate */
 	"IBSP",				/* bsp file prefix */
 	47,					/* bsp file version */
Index: tools/quake3/q3map2/game_ef.h
===================================================================
--- tools/quake3/q3map2/game_ef.h.orig	2008-09-06 15:32:04.000000000 +0200
+++ tools/quake3/q3map2/game_ef.h	2008-09-06 15:32:16.000000000 +0200
@@ -113,6 +113,7 @@
 	qfalse,				/* wolf lighting model? */
 	128,				/* lightmap width/height */
 	1.0f,				/* lightmap gamma */
+	1.0f,				/* lightmap exposure */
 	1.0f,				/* lightmap compensate */
 	"IBSP",				/* bsp file prefix */
 	46,					/* bsp file version */
Index: tools/quake3/q3map2/light_ydnar.c
===================================================================
--- tools/quake3/q3map2/light_ydnar.c.orig	2008-09-06 15:32:14.000000000 +0200
+++ tools/quake3/q3map2/light_ydnar.c	2008-09-06 15:32:16.000000000 +0200
@@ -49,6 +49,7 @@
 	int		i;
 	float	max, gamma;
 	vec3_t	sample;
+	float 	inv, dif;
 	
 	
 	/* ydnar: scaling necessary for simulating r_overbrightBits on external lightmaps */
@@ -72,15 +73,50 @@
 		/* gamma */
 		sample[ i ] = pow( sample[ i ] / 255.0f, gamma ) * 255.0f;
 	}
-	
-	/* clamp with color normalization */
-	max = sample[ 0 ];
-	if( sample[ 1 ] > max )
-		max = sample[ 1 ];
-	if( sample[ 2 ] > max )
-		max = sample[ 2 ];
-	if( max > 255.0f )
-		VectorScale( sample, (255.0f / max), sample );
+
+	if (lightmapExposure == 1)
+	{
+		/* clamp with color normalization */
+		max = sample[ 0 ];
+		if( sample[ 1 ] > max )
+			max = sample[ 1 ];
+		if( sample[ 2 ] > max )
+			max = sample[ 2 ];
+		if( max > 255.0f )
+			VectorScale( sample, (255.0f / max), sample );
+	}
+	else
+	{
+		if (lightmapExposure==0)
+		{
+			lightmapExposure=1.0f;
+		}
+		inv=1.f/lightmapExposure;
+		//Exposure
+
+		max = sample[ 0 ];
+		if( sample[ 1 ] > max )
+			max = sample[ 1 ];
+		if( sample[ 2 ] > max )
+			max = sample[ 2 ];
+
+		dif = (1-  exp(-max * inv) )  *  255;
+
+		if (max >0)
+		{
+			dif = dif / max;
+		}
+		else
+		{
+			dif = 0;
+		}
+
+		for (i=0;i<3;i++)
+		{
+			sample[i]*=dif;
+		}
+	}
+
 	
 	/* compensate for ingame overbrighting/bitshifting */
 	VectorScale( sample, (1.0f / lightmapCompensate), sample );
Index: tools/quake3/q3map2/q3map2.h
===================================================================
--- tools/quake3/q3map2/q3map2.h.orig	2008-09-06 15:32:14.000000000 +0200
+++ tools/quake3/q3map2/q3map2.h	2008-09-06 15:32:16.000000000 +0200
@@ -553,6 +553,7 @@
 	qboolean			wolfLight;						/* when true, lights work like wolf q3map  */
 	int					lightmapSize;					/* bsp lightmap width/height */
 	float				lightmapGamma;					/* default lightmap gamma */
+	float				lightmapExposure;				/* default lightmap exposure */
 	float				lightmapCompensate;				/* default lightmap compensate value */
 	char				*bspIdent;						/* 4-letter bsp file prefix */
 	int					bspVersion;						/* bsp version to use */
@@ -2139,6 +2140,7 @@
 
 /* ydnar: lightmap gamma/compensation */
 Q_EXTERN float				lightmapGamma Q_ASSIGN( 1.0f );
+Q_EXTERN float				lightmapExposure Q_ASSIGN( 1.0f );
 Q_EXTERN float				lightmapCompensate Q_ASSIGN( 1.0f );
 
 /* ydnar: for runtime tweaking of falloff tolerance */
Index: tools/quake3/q3map2/light.c
===================================================================
--- tools/quake3/q3map2/light.c.orig	2008-09-06 15:32:14.000000000 +0200
+++ tools/quake3/q3map2/light.c	2008-09-06 15:32:16.000000000 +0200
@@ -1893,6 +1893,14 @@
 			i++;
 		}
 		
+		else if( !strcmp( argv[ i ], "-exposure" ) )
+		{
+			f = atof( argv[ i + 1 ] );
+			lightmapExposure = f;
+			Sys_Printf( "Lighting exposure set to %f\n", lightmapExposure );
+			i++;
+		}
+
 		else if( !strcmp( argv[ i ], "-compensate" ) )
 		{
 			f = atof( argv[ i + 1 ] );
Index: tools/quake3/q3map2/light_ydnar.c
===================================================================
--- tools/quake3/q3map2/light_ydnar.c.orig	2008-09-06 15:32:16.000000000 +0200
+++ tools/quake3/q3map2/light_ydnar.c	2008-09-06 15:32:18.000000000 +0200
@@ -420,7 +420,7 @@
 #define NUDGE			0.5f
 #define BOGUS_NUDGE		-99999.0f
 
-static int MapSingleLuxel( rawLightmap_t *lm, surfaceInfo_t *info, bspDrawVert_t *dv, vec4_t plane, float pass, vec3_t stv[ 3 ], vec3_t ttv[ 3 ] )
+static int MapSingleLuxel( rawLightmap_t *lm, surfaceInfo_t *info, bspDrawVert_t *dv, vec4_t plane, float pass, vec3_t stv[ 3 ], vec3_t ttv[ 3 ], vec3_t worldverts[ 3 ] )
 {
 	int				i, x, y, numClusters, *clusters, pointCluster, *cluster;
 	float			*luxel, *origin, *normal, d, lightmapSampleOffset;
@@ -428,6 +428,12 @@
 	vec3_t			pNormal;
 	vec3_t			vecs[ 3 ];
 	vec3_t			nudged;
+	vec3_t			cverts[ 3 ];
+	vec3_t			temp;
+	vec4_t			sideplane, hostplane;
+	vec3_t			origintwo;
+	int				j, next;
+	float			e;
 	float			*nudge;
 	static float	nudges[][ 2 ] =
 					{
@@ -521,6 +527,51 @@
 	/* non axial lightmap projection (explicit xyz) */
 	else
 		VectorCopy( dv->xyz, origin );
+
+	//////////////////////
+	//27's test to make sure samples stay within the triangle boundaries
+	//1) Test the sample origin to see if it lays on the wrong side of any edge (x/y)
+	//2) if it does, nudge it onto the correct side.
+
+	if (worldverts!=NULL)
+	{
+		for (j=0;j<3;j++)
+		{
+			VectorCopy(worldverts[j],cverts[j]);
+		}
+		PlaneFromPoints(hostplane,cverts[0],cverts[1],cverts[2]);
+
+		for (j=0;j<3;j++)
+		{
+			for (i=0;i<3;i++)
+			{
+				//build plane using 2 edges and a normal
+				next=(i+1)%3;
+
+				VectorCopy(cverts[next],temp);
+				VectorAdd(temp,hostplane,temp);
+				PlaneFromPoints(sideplane,cverts[i],cverts[ next ], temp);
+
+				//planetest sample point
+				e=DotProduct(origin,sideplane);
+				e=e-sideplane[3];
+				if (e>0)
+				{
+					//we're bad.
+					//VectorClear(origin);
+					//Move the sample point back inside triangle bounds
+					origin[0]-=sideplane[0]*(e+1);
+					origin[1]-=sideplane[1]*(e+1);
+					origin[2]-=sideplane[2]*(e+1);
+#ifdef DEBUG_27_1
+					VectorClear(origin);
+#endif
+				}
+			}
+		}
+	}
+
+	////////////////////////
 	
 	/* planar surfaces have precalculated lightmap vectors for nudging */
 	if( lm->plane != NULL )
@@ -552,8 +603,13 @@
 	else
 		origin[ lm->axisNum ] += lightmapSampleOffset;
 	
+	VectorCopy(origin,origintwo);
+	origintwo[0]+=vecs[2][0];
+	origintwo[1]+=vecs[2][1];
+	origintwo[2]+=vecs[2][2];
+
 	/* get cluster */
-	pointCluster = ClusterForPointExtFilter( origin, LUXEL_EPSILON, numClusters, clusters );
+	pointCluster = ClusterForPointExtFilter( origintwo, LUXEL_EPSILON, numClusters, clusters );
 	
 	/* another retarded hack, storing nudge count in luxel[ 1 ] */
 	luxel[ 1 ] = 0.0f;	
@@ -569,14 +625,14 @@
 			for( i = 0; i < 3; i++ )
 			{
 				/* set nudged point*/
-				nudged[ i ] = origin[ i ] + (nudge[ 0 ] * vecs[ 0 ][ i ]) + (nudge[ 1 ] * vecs[ 1 ][ i ]);
+				nudged[ i ] = origintwo[ i ] + (nudge[ 0 ] * vecs[ 0 ][ i ]) + (nudge[ 1 ] * vecs[ 1 ][ i ]);
 			}
 			nudge += 2;
 			
 			/* get pvs cluster */
 			pointCluster = ClusterForPointExtFilter( nudged, LUXEL_EPSILON, numClusters, clusters ); //% + 0.625 );
-			if( pointCluster >= 0 )	
-				VectorCopy( nudged, origin );
+			//if( pointCluster >= 0 )
+   			//	VectorCopy( nudged, origin );
 			luxel[ 1 ] += 1.0f;
 		}
 	}
@@ -586,8 +642,8 @@
 	{
 		VectorMA( dv->xyz, lightmapSampleOffset, dv->normal, nudged );
 		pointCluster = ClusterForPointExtFilter( nudged, LUXEL_EPSILON, numClusters, clusters );
-		if( pointCluster >= 0 )
-			VectorCopy( nudged, origin );
+		//if( pointCluster >= 0 )
+		//	VectorCopy( nudged, origin );
 		luxel[ 1 ] += 1.0f;
 	}
 	
@@ -633,7 +689,7 @@
 than the distance between two luxels (thanks jc :)
 */
 
-static void MapTriangle_r( rawLightmap_t *lm, surfaceInfo_t *info, bspDrawVert_t *dv[ 3 ], vec4_t plane, vec3_t stv[ 3 ], vec3_t ttv[ 3 ] )
+static void MapTriangle_r( rawLightmap_t *lm, surfaceInfo_t *info, bspDrawVert_t *dv[ 3 ], vec4_t plane, vec3_t stv[ 3 ], vec3_t ttv[ 3 ], vec3_t worldverts[ 3 ] )
 {
 	bspDrawVert_t	mid, *dv2[ 3 ];
 	int				max;
@@ -681,7 +737,7 @@
 	
 	/* split the longest edge and map it */
 	LerpDrawVert( dv[ max ], dv[ (max + 1) % 3 ], &mid );
-	MapSingleLuxel( lm, info, &mid, plane, 1, stv, ttv );
+	MapSingleLuxel( lm, info, &mid, plane, 1, stv, ttv, worldverts );
 	
 	/* push the point up a little bit to account for fp creep (fixme: revisit this) */
 	//%	VectorMA( mid.xyz, 2.0f, mid.normal, mid.xyz );
@@ -689,12 +745,12 @@
 	/* recurse to first triangle */
 	VectorCopy( dv, dv2 );
 	dv2[ max ] = &mid;
-	MapTriangle_r( lm, info, dv2, plane, stv, ttv );
+	MapTriangle_r( lm, info, dv2, plane, stv, ttv, worldverts );
 	
 	/* recurse to second triangle */
 	VectorCopy( dv, dv2 );
 	dv2[ (max + 1) % 3 ] = &mid;
-	MapTriangle_r( lm, info, dv2, plane, stv, ttv );
+	MapTriangle_r( lm, info, dv2, plane, stv, ttv, worldverts );
 }
 
 
@@ -710,6 +766,7 @@
 	int				i;
 	vec4_t			plane;
 	vec3_t			*stv, *ttv, stvStatic[ 3 ], ttvStatic[ 3 ];
+	vec3_t			worldverts[ 3 ];
 	
 	
 	/* get plane if possible */
@@ -735,16 +792,20 @@
 		ttv = NULL;
 	}
 	
+	VectorCopy( dv[ 0 ]->xyz, worldverts[ 0 ] );
+	VectorCopy( dv[ 1 ]->xyz, worldverts[ 1 ] );
+	VectorCopy( dv[ 2 ]->xyz, worldverts[ 2 ] );
+
 	/* map the vertexes */
-	MapSingleLuxel( lm, info, dv[ 0 ], plane, 1, stv, ttv );
-	MapSingleLuxel( lm, info, dv[ 1 ], plane, 1, stv, ttv );
-	MapSingleLuxel( lm, info, dv[ 2 ], plane, 1, stv, ttv );
+	MapSingleLuxel( lm, info, dv[ 0 ], plane, 1, stv, ttv, worldverts );
+	MapSingleLuxel( lm, info, dv[ 1 ], plane, 1, stv, ttv, worldverts );
+	MapSingleLuxel( lm, info, dv[ 2 ], plane, 1, stv, ttv, worldverts );
 	
 	/* 2002-11-20: prefer axial triangle edges */
 	if( mapNonAxial )
 	{
 		/* subdivide the triangle */
-		MapTriangle_r( lm, info, dv, plane, stv, ttv );
+		MapTriangle_r( lm, info, dv, plane, stv, ttv, worldverts );
 		return qtrue;
 	}
 	
@@ -766,7 +827,7 @@
 			dv2[ 2 ] = dv[ (i + 1) % 3 ];
 			
 			/* map the degenerate triangle */
-			MapTriangle_r( lm, info, dv2, plane, stv, ttv );
+			MapTriangle_r( lm, info, dv2, plane, stv, ttv, worldverts );
 		}
 	}
 	
@@ -828,8 +889,8 @@
 	LerpDrawVert( dv[ max + 2 ], dv[ (max + 3) % 4 ], &mid[ 1 ] );
 	
 	/* map the vertexes */
-	MapSingleLuxel( lm, info, &mid[ 0 ], plane, 1, stv, ttv );
-	MapSingleLuxel( lm, info, &mid[ 1 ], plane, 1, stv, ttv );
+	MapSingleLuxel( lm, info, &mid[ 0 ], plane, 1, stv, ttv, NULL );
+	MapSingleLuxel( lm, info, &mid[ 1 ], plane, 1, stv, ttv, NULL );
 	
 	/* 0 and 2 */
 	if( max == 0 )
@@ -914,10 +975,10 @@
 	}
 	
 	/* map the vertexes */
-	MapSingleLuxel( lm, info, dv[ 0 ], plane, 1, stv, ttv );
-	MapSingleLuxel( lm, info, dv[ 1 ], plane, 1, stv, ttv );
-	MapSingleLuxel( lm, info, dv[ 2 ], plane, 1, stv, ttv );
-	MapSingleLuxel( lm, info, dv[ 3 ], plane, 1, stv, ttv );
+	MapSingleLuxel( lm, info, dv[ 0 ], plane, 1, stv, ttv, NULL );
+	MapSingleLuxel( lm, info, dv[ 1 ], plane, 1, stv, ttv, NULL );
+	MapSingleLuxel( lm, info, dv[ 2 ], plane, 1, stv, ttv, NULL );
+	MapSingleLuxel( lm, info, dv[ 3 ], plane, 1, stv, ttv, NULL );
 	
 	/* subdivide the quad */
 	MapQuad_r( lm, info, dv, plane, stv, ttv );
@@ -1209,7 +1270,7 @@
 					continue;
 				
 				/* map the fake vert */
-				MapSingleLuxel( lm, NULL, &fake, lm->plane, pass, NULL, NULL );
+				MapSingleLuxel( lm, NULL, &fake, lm->plane, pass, NULL, NULL, NULL );
 			}
 		}
 	}
@@ -2001,22 +2062,32 @@
 					deluxel = SUPER_DELUXEL( x, y );
 					origin = SUPER_ORIGIN( x, y );
 					normal = SUPER_NORMAL( x, y );
-					
-					/* set contribution count */
-					lightLuxel[ 3 ] = 1.0f;
-					
-					/* setup trace */
-					trace.cluster = *cluster;
-					VectorCopy( origin, trace.origin );
-					VectorCopy( normal, trace.normal );
-					
-					/* get light for this sample */
-					LightContributionToSample( &trace );
-					VectorCopy( trace.color, lightLuxel );
-					
-					/* add to count */
-					if( trace.color[ 0 ] || trace.color[ 1 ] || trace.color[ 2 ] )
+
+					////////// 27's temp hack for testing edge clipping ////
+					if( origin[0]==0 && origin[1]==0 && origin[2]==0 )
+					{
+						lightLuxel[ 1 ] = 255;
+						lightLuxel[ 3 ] = 1.0f;
 						totalLighted++;
+					}
+					else
+					{
+						/* set contribution count */
+						lightLuxel[ 3 ] = 1.0f;
+
+						/* setup trace */
+						trace.cluster = *cluster;
+						VectorCopy( origin, trace.origin );
+						VectorCopy( normal, trace.normal );
+
+						/* get light for this sample */
+						LightContributionToSample( &trace );
+						VectorCopy( trace.color, lightLuxel );
+
+						/* add to count */
+						if( trace.color[ 0 ] || trace.color[ 1 ] || trace.color[ 2 ] )
+							totalLighted++;
+					}
 					
 					/* add to light direction map (fixme: use luxel normal as starting point for deluxel?) */
 					if( deluxemap )
Index: tools/quake3/q3map2/q3map2.h
===================================================================
--- tools/quake3/q3map2/q3map2.h	(revision 303)
+++ tools/quake3/q3map2/q3map2.h	(working copy)
@@ -35,8 +35,8 @@
 
 
 /* version */
-#define Q3MAP_VERSION	"2.5.17"
-#define Q3MAP_MOTD		"Last one turns the lights off"
+#define Q3MAP_VERSION	"2.5.17-div0-obj-decomptexcoords-snapplane-UTavgcolorfix-UTfloodlight-UTlmexposure-UTtrianglecheck"
+#define Q3MAP_MOTD		"Light some candles, put them on a wooden table, take a photo, and paste it on the lightmaps!"
 
 
 
Index: include/version.default
===================================================================
--- include/version.default	(revision 290)
+++ include/version.default	(working copy)
@@ -1 +1 @@
-1.4.0
+1.4.0-div0-obj-targetname
