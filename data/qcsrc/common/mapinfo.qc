// HUGE SET - stored in a string
string HugeSetOfIntegers_empty()
{
	return "";
}
float HugeSetOfIntegers_get(string pArr, float i)
{
	return stof(substring(pArr, i * 4, 4));
}
float HugeSetOfIntegers_length(string pArr)
{
	return strlen(pArr) / 4;
}
string HugeSetOfIntegers_concat(string a1, string a2)
{
	return strcat(a1, a2);
}
string HugeSetOfIntegers_insert(string a1, float n, string a2)
	// special concat function to build up large lists in less time by binary concatenation
{
	string s;
	s = strcat("    ", ftos(n));
	return strcat(a1, substring(s, strlen(s) - 4, 4), a2);
}

// generic string stuff
float startsWith(string haystack, string needle)
{
	return substring(haystack, 0, strlen(needle)) == needle;
}
string extractRestOfLine(string haystack, string needle)
{
	if(startsWith(haystack, needle))
		return substring(haystack, strlen(needle), strlen(haystack) - strlen(needle));
	return string_null;
}

// GLOB HANDLING (for all BSP files)
float _MapInfo_globopen;
float _MapInfo_globcount; 
float _MapInfo_globhandle;
string _MapInfo_GlobItem(float i)
{
	string s;
	s = search_getfilename(_MapInfo_globhandle, i);
	return substring(s, 5, strlen(s) - 9); // without maps/ and .bsp
}

void MapInfo_Enumerate()
{
	if(_MapInfo_globopen)
		search_end(_MapInfo_globhandle);
	_MapInfo_globhandle = search_begin("maps/*.bsp", TRUE, TRUE);
	_MapInfo_globcount = search_getsize(_MapInfo_globhandle);
	_MapInfo_globopen = 1;
}

// filter the info by game type mask (updates MapInfo_count)
string _MapInfo_filtered;
string MapInfo_FilterGametype_Recursive(float pGametype, float pBegin, float pEnd)
{
	float m;
	string l, r;

	if(pBegin == pEnd)
		return HugeSetOfIntegers_empty();

	m = floor((pBegin + pEnd) / 2);

	l = MapInfo_FilterGametype_Recursive(pGametype, pBegin, m);
	if not(l)
		return string_null; // BAIL OUT
	if(MapInfo_Get_ByName(_MapInfo_GlobItem(m), 1) == 2) // if we generated one... BAIL OUT and let the caller continue in the next frame.
		return string_null; // BAIL OUT
	r = MapInfo_FilterGametype_Recursive(pGametype, m + 1, pEnd);
	if not(r)
		return string_null; // BAIL OUT

	if(MapInfo_Map_supportedGametypes & pGametype)
		return HugeSetOfIntegers_insert(l, m, r);
	else
		return HugeSetOfIntegers_concat(l, r);
}
float MapInfo_FilterGametype(float gametype)
{
	if(_MapInfo_filtered)
		strunzone(_MapInfo_filtered);
	_MapInfo_filtered = MapInfo_FilterGametype_Recursive(gametype, 0, _MapInfo_globcount);
	if(!_MapInfo_filtered)
	{
		dprint("Autogenerated a .mapinfo, doing the rest later.\n");
		return 0;
	}
	_MapInfo_filtered = strzone(_MapInfo_filtered);
	MapInfo_count = HugeSetOfIntegers_length(_MapInfo_filtered);
	dprint("Filter ", ftos(gametype), " results in ", _MapInfo_filtered, "\n");
	return 1;
}

// load info about the i-th map into the MapInfo_Map_* globals
float MapInfo_Get_ByID(float i); // 1 on success, 0 on failure

float _MapInfo_Generate(string pFilename)
{
	string fn;
	float fh;
	string s, v;
	vector o;
	float inWorldspawn, l;

	float spawns, diameter;
	vector mapMins, mapMaxs;

	fn = strcat("maps/", pFilename, ".ent");
	fh = fopen(fn, FILE_READ);
	if(fh < 0)
	{
		fn = strcat("maps/", pFilename, ".bsp");
		fh = fopen(fn, FILE_READ);
	}
	if(fh < 0)
		return 0;
	dprint("Analyzing ", fn, " to generate initial mapinfo\n");

	MapInfo_Map_supportedGametypes |= MAPINFO_TYPE_DEATHMATCH;      // DM always works
	MapInfo_Map_supportedGametypes |= MAPINFO_TYPE_RUNEMATCH;       // Rune always works
	MapInfo_Map_supportedGametypes |= MAPINFO_TYPE_LMS;             // LMS always works

	inWorldspawn = 2;

	for(;;)
	{
		if not((s = fgets(fh)))
			break;
		if(inWorldspawn == 1)
			if(startsWith(s, "}"))
				inWorldspawn = 0;
		if(inWorldspawn)
		{
			if(startsWith(s, "\"classname\" \"worldspawn\""))
				inWorldspawn = 1;
			else if((v = extractRestOfLine(s, "\"message\" \"")))
			{
				for(l = strlen(v) - 1; l > 0; --l)
					if(substring(v, l, 1) == "\"")
						break;
				MapInfo_Map_title = substring(v, 0, l);
			}
		}
		else
		{
			if((v = extractRestOfLine(s, "\"origin\" \"")))
			{
				for(l = strlen(v) - 1; l > 0; --l)
					if(substring(v, l, 1) == "\"")
						break;
				o = stov(strcat("'", substring(v, 0, l), "'"));
				mapMins_x = min(mapMins_x, o_x);
				mapMins_y = min(mapMins_y, o_y);
				mapMins_z = min(mapMins_z, o_z);
				mapMaxs_x = max(mapMaxs_x, o_x);
				mapMaxs_y = max(mapMaxs_y, o_y);
				mapMaxs_z = max(mapMaxs_z, o_z);
			}
			else if((v = extractRestOfLine(s, "\"classname\" \"")))
			{
				if(startsWith(v, "dom_controlpoint\""))
					MapInfo_Map_supportedGametypes |= MAPINFO_TYPE_DOMINATION;
				else if(startsWith(v, "item_flag_team2\""))
					MapInfo_Map_supportedGametypes |= MAPINFO_TYPE_CTF;
				else if(startsWith(v, "runematch_spawn_point\""))
					MapInfo_Map_supportedGametypes |= MAPINFO_TYPE_RUNEMATCH;
				else if(startsWith(v, "target_assault_roundend\""))
					MapInfo_Map_supportedGametypes |= MAPINFO_TYPE_ASSAULT;
				else if(startsWith(v, "onslaught_generator\""))
					MapInfo_Map_supportedGametypes |= MAPINFO_TYPE_ONSLAUGHT;
				else if(startsWith(v, "info_player_team1\""))
					++spawns;
				else if(startsWith(v, "info_player_team2\""))
					++spawns;
				else if(startsWith(v, "info_player_deathmatch\""))
					++spawns;
				else if(startsWith(v, "info_player_start\""))
					++spawns;
			}
		}
	}
	if(inWorldspawn)
	{
		print(strcat(fn, " ended still in worldspawn, BUG"));
		return 0;
	}
	diameter = vlen(mapMaxs - mapMins);
	if(spawns >= 8  && diameter > 2048)
		MapInfo_Map_supportedGametypes |= MAPINFO_TYPE_TEAM_DEATHMATCH;
	if(                diameter < 4096)
		MapInfo_Map_supportedGametypes |= MAPINFO_TYPE_ARENA;
	if(spawns >= 16 && diameter > 4096)
		MapInfo_Map_supportedGametypes |= MAPINFO_TYPE_KEYHUNT;
	fclose(fh);
	dprint(fn, ": types = ", ftos(MapInfo_Map_supportedGametypes), " spawns ", ftos(spawns), " diameter ", ftos(diameter), "\n");
	return 1;
}

// load info about a map by name into the MapInfo_Map_* globals
float MapInfo_Get_ByName(string pFilename, float pAllowGenerate)
{
	string fn;
	string s, t;
	float fh;

	// default all generic fields so they have "good" values in case something fails
	MapInfo_Map_title = "Untitled1";
	MapInfo_Map_description = "Bleh.";
	MapInfo_Map_supportedGametypes = 0;

	fn = strcat("maps/", pFilename, ".mapinfo");
	fh = fopen(fn, FILE_READ);
	if(fh < 0)
	{
		if(!pAllowGenerate)
			return 0;
		if(!_MapInfo_Generate(pFilename))
			return 0;
		fh = fopen(fn, FILE_WRITE);
		fputs(fh, strcat("title ", MapInfo_Map_title, "\n"));
		fputs(fh, strcat("description ", MapInfo_Map_description, "\n"));
		if(MapInfo_Map_supportedGametypes & MAPINFO_TYPE_DEATHMATCH)      fputs(fh, "type dm 30 20\n");
		if(MapInfo_Map_supportedGametypes & MAPINFO_TYPE_TEAM_DEATHMATCH) fputs(fh, "type tdm 50 20 2\n"); // TODO count tdm_team entities
		if(MapInfo_Map_supportedGametypes & MAPINFO_TYPE_DOMINATION)      fputs(fh, "type dom 200 20 2\n"); // TODO count tdm_team entities
		if(MapInfo_Map_supportedGametypes & MAPINFO_TYPE_CTF)             fputs(fh, "type ctf 300 20\n");
		if(MapInfo_Map_supportedGametypes & MAPINFO_TYPE_RUNEMATCH)       fputs(fh, "type rune 200 20\n");
		if(MapInfo_Map_supportedGametypes & MAPINFO_TYPE_LMS)             fputs(fh, "type lms 9 20\n");
		if(MapInfo_Map_supportedGametypes & MAPINFO_TYPE_ARENA)           fputs(fh, "type arena 10 20\n");
		if(MapInfo_Map_supportedGametypes & MAPINFO_TYPE_KEYHUNT)         fputs(fh, "type kh 1000 20\n");
		if(MapInfo_Map_supportedGametypes & MAPINFO_TYPE_ASSAULT)         fputs(fh, "type as 20\n");
		if(MapInfo_Map_supportedGametypes & MAPINFO_TYPE_ONSLAUGHT)       fputs(fh, "type ons 20\n");
		fclose(fh);
		return 2;
	}
	for(;;)
	{
		if not((s = fgets(fh)))
			break;
		tokenize(s);
		t = argv(0);
		if(t == "title")
			MapInfo_Map_title = substring(s, 6, strlen(s) - 6); // without "title"
		else if(t == "description")
			MapInfo_Map_description = substring(s, 12, strlen(s) - 12);
		else if(t == "type")
		{
			t = argv(1);
			if     (t == "dm")    MapInfo_Map_supportedGametypes |= MAPINFO_TYPE_DEATHMATCH;
			else if(t == "tdm")   MapInfo_Map_supportedGametypes |= MAPINFO_TYPE_TEAM_DEATHMATCH;
			else if(t == "dom")   MapInfo_Map_supportedGametypes |= MAPINFO_TYPE_DOMINATION;
			else if(t == "ctf")   MapInfo_Map_supportedGametypes |= MAPINFO_TYPE_CTF;
			else if(t == "rune")  MapInfo_Map_supportedGametypes |= MAPINFO_TYPE_RUNEMATCH;
			else if(t == "lms")   MapInfo_Map_supportedGametypes |= MAPINFO_TYPE_LMS;
			else if(t == "arena") MapInfo_Map_supportedGametypes |= MAPINFO_TYPE_ARENA;
			else if(t == "kh")    MapInfo_Map_supportedGametypes |= MAPINFO_TYPE_KEYHUNT;
			else if(t == "as")    MapInfo_Map_supportedGametypes |= MAPINFO_TYPE_ASSAULT;
			else if(t == "ons")   MapInfo_Map_supportedGametypes |= MAPINFO_TYPE_ONSLAUGHT;
			else
				dprint("Map ", pFilename, " supports unknown game type ", t, ", ignored\n");
		}
		else
			dprint("Map ", pFilename, " supports unknown game type ", t, ", ignored\n");
	}
	fclose(fh);
	if(MapInfo_Map_supportedGametypes != 0)
		return 1;
	dprint("Map ", pFilename, " supports no game types, ignored\n");
	return 0;
}
