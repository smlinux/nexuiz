entity nagger;
float readycount;
float Nagger_SendEntity(entity to, float sendflags)
{
	float nags;
	WriteByte(MSG_ENTITY, ENT_CLIENT_NAGGER);

	nags = 0;
	if(readycount)
	{
		nags |= 1;
		if(to.ready == 0)
			nags |= 2;
	}
	if(votecalled)
	{
		nags |= 4;
		if(to.vote_vote == 0)
			nags |= 8;
	}

	if(sendflags & 128)
	{
		WriteByte(MSG_ENTITY, nags | 128);
		if(votecalled)
			WriteString(MSG_ENTITY, votecalledvote_display);
		else
			WriteString(MSG_ENTITY, "");
	}
	else
		WriteByte(MSG_ENTITY, nags);

	return TRUE;
}
void Nagger_Init()
{
	nagger = spawn();
	Net_LinkEntity(nagger);
	nagger.SendFlags = 128;
	nagger.SendEntity = Nagger_SendEntity;
}
void Nagger_VoteChanged()
{
	if(nagger)
		nagger.SendFlags = 128;
}
void Nagger_VoteCountChanged()
{
	if(nagger)
		nagger.SendFlags = 1;
}
void Nagger_ReadyCounted()
{
	if(nagger)
		nagger.SendFlags = 1;
}

void ReadyCount();
string MapVote_Suggest(string m);

.float floodcontrol_chat;
.float floodcontrol_team;
void Say(entity source, float teamsay, string msgin)
{
	string msgstr, colorstr, cmsgstr, namestr;
	float flood;
	entity head;

	if(Ban_MaybeEnforceBan(source))
		return;

	if(!teamsay)
		if(substring(msgin, 0, 1) == " ")
			msgin = substring(msgin, 1, strlen(msgin) - 1); // work around DP say bug (say_team does not have this!)

	msgin = formatmessage(msgin);

	if(msgin == "")
		return;

	if(source.classname != "player")
		colorstr = "^0"; // black for spectators
	else if(teams_matter)
		colorstr = Team_ColorCode(source.team);
	else
		teamsay = FALSE;

	if(intermission_running)
		teamsay = FALSE;

	/*
	 * using bprint solves this... me stupid
	// how can we prevent the message from appearing in a listen server?
	// for now, just give "say" back and only handle say_team
	if(!teamsay)
	{
		clientcommand(self, strcat("say ", msgin));
		return;
	}
	*/

	if(cvar("g_chat_teamcolors"))
		namestr = playername(source);
	else
		namestr = source.netname;
	if(teamsay)
	{
		msgstr = strzone(strcat("\{1}\{13}", colorstr, "(^3", namestr, colorstr, ") ^7", msgin, "\n"));
		cmsgstr = strcat(colorstr, "(^3", namestr, colorstr, ")\n^7", wordwrap(msgin, 50));
	}
	else
		msgstr = strzone(strcat("\{1}", namestr, "^7: ", msgin, "\n"));

	// FLOOD CONTROL
	flood = 0;
	{
		float flood_spl;
		float flood_burst;
		float flood_lmax;
		var .float flood_field;
		float lines;
		if(teamsay)
		{
			flood_spl = cvar("g_chat_flood_spl_team");
			flood_burst = cvar("g_chat_flood_burst_team");
			flood_lmax = cvar("g_chat_flood_lmax_team");
			flood_field = floodcontrol_team;
		}
		else
		{
			flood_spl = cvar("g_chat_flood_spl");
			flood_burst = cvar("g_chat_flood_burst");
			flood_lmax = cvar("g_chat_flood_lmax");
			flood_field = floodcontrol_chat;
		}
		flood_burst = max(0, flood_burst - 1);
		// to match explanation in default.cfg, a value of 3 must allow three-line bursts and not four!
		lines = ceil(strlennocol(msgstr) / 75);
		if(flood_lmax && lines > flood_lmax)
			flood = 2;
		else if(time >= self.flood_field)
			self.flood_field = max(time - flood_burst * flood_spl, self.flood_field) + lines * flood_spl;
		else
			flood = 1;
	}

	if(flood)
	{
		if(cvar("g_chat_flood_notify_flooder"))
		{
			if(flood == 1)
				sprint(self, strcat("^3FLOOD CONTROL: ^7wait ^1", ftos(self.flood_field - time), "^3 seconds\n"));
			else if(flood == 2)
				sprint(self, "^3FLOOD CONTROL: ^7message too long\n");
		}
		else
			sprint(self, msgstr);
		print("NOTE: ", playername(self), "^7 is flooding.\n");
	}
	else if(teamsay)
	{
		if(source.classname == "player")
		{
			FOR_EACH_REALPLAYER(head)
			{
				if(head.team == source.team)
				{
					sprint(head, msgstr);
					centerprint(head, cmsgstr);
				}
			}
		}
		else
		{
			FOR_EACH_REALCLIENT(head) if(head.classname != "player")
			{
				sprint(head, msgstr);
				centerprint(head, cmsgstr);
			}
		}
	}
	else
	{
		// TODO invent a cvar name for allowing global chat by spectators during warmup anyway
		if(cvar("g_chat_nospectators") && source.classname != "player") {
			FOR_EACH_REALCLIENT(head) if(head.classname != "player") {
				sprint(head, msgstr);
			}
		}
		else
			bprint(msgstr);
	}

	strunzone(msgstr);
}

entity GetPlayer(string name)
{
	float num;
	entity e;
	string ns;

	if(substring(name, 0, 1) == "#") {
		num = stof(substring(name, 1, 999));
		if(num >= 1 && num <= maxclients) {
			for((e = world); num > 0; --num, (e = nextent(e)))
				;
			//if(clienttype(e) == CLIENTTYPE_REAL)
			if(e.classname == "player")
				return e;
		}
	} else {
		ns = strdecolorize(name);
		FOR_EACH_REALPLAYER(e) {
			if(!strcasecmp(strdecolorize(e.netname), ns)) {
				return e;
			}
		}
	}
	return world;
}

//float ctf_clientcommand();
float readyrestart_happened;
void SV_ParseClientCommand(string s) {
	local string cmd;
	local float i, j, tokens, f, effectnum;
	local vector start, end;

	tokens = tokenize_sane(s);

	if(GameCommand_Vote(s, self)) {
		return;
	} else if(GameCommand_MapVote(argv(0))) {
		return;
	} else if(argv(0) == "autoswitch") {
		// be backwards compatible with older clients (enabled)
		self.autoswitch = ("0" != argv(1));
		local string autoswitchmsg;
		if (self.autoswitch) {
			autoswitchmsg = "on";
		} else {
			autoswitchmsg = "off";
		}
		sprint(self, strcat("^1autoswitch turned ", autoswitchmsg, "\n"));
	} else if(argv(0) == "clientversion") {
		if not(self.flags & FL_CLIENT)
			return;
		if (argv(1) == "$gameversion") {
			//versionmsg = "^1client is too old to get versioninfo.\nUPDATE!!! (http://www.nexuiz.com)^8";
			// either that or someone wants to be funny
			self.version = 1;
		} else {
			self.version = stof(argv(1));
		}
		if(self.version != cvar("gameversion"))
		{
			self.classname = "observer";
			self.version_mismatch = 1;
			PutClientInServer();
		} else if(cvar("g_campaign") || cvar("g_balance_teams") || cvar("g_balance_teams_force")) {
			//JoinBestTeam(self, FALSE, TRUE);
		} else if(cvar("teamplay") && !cvar("sv_spectate")) {
			self.classname = "observer";
			stuffcmd(self,"menu_showteamselect\n");
		}
	} else if(argv(0) == "reportcvar") { // old system
		GetCvars(1);
	} else if(argv(0) == "sentcvar") { // new system
		GetCvars(1);
	} else if(argv(0) == "spectate") {
		if not(self.flags & FL_CLIENT)
			return;
		if(g_lms || g_arena)
			return; // don't allow spectating in lms, unless player runs out of lives
		if(self.classname == "player" && cvar("sv_spectate") == 1) {
			if(self.flagcarried)
				DropFlag(self.flagcarried, world, world);
			kh_Key_DropAll(self, TRUE);
			WaypointSprite_PlayerDead();
			self.classname = "observer";
			if(blockSpectators)
				sprint(self, strcat("^7You have to become a player within the next ", ftos(cvar("g_maxplayers_spectator_blocktime")), " seconds, otherwise you will be kicked, because spectators aren't allowed at this time!\n"));
			PutClientInServer();
		}
	} else if(argv(0) == "join") {
		if not(self.flags & FL_CLIENT)
			return;
		if(!g_arena)
		if (self.classname != "player" && !lockteams)
		{
			if(isJoinAllowed()) {
				self.classname = "player";
				PlayerScore_Clear(self);
				bprint ("^4", self.netname, "^4 is playing now\n");
				PutClientInServer();
			}
			else {
				//player may not join because of g_maxplayers is set
				centerprint_atprio(self, CENTERPRIO_MAPVOTE, PREVENT_JOIN_TEXT);
			}
		}
	} else if( argv(0) == "selectteam" ) {
		if not(self.flags & FL_CLIENT)
			return;
		if( !cvar("teamplay") ) {
			sprint( self, "selecteam can only be used in teamgames\n");
		} else if(cvar("g_campaign")) {
			//JoinBestTeam(self, 0);
		} else if(lockteams) {
			sprint( self, "^7The game has already begun, you must wait until the next map to be able to join a team.\n");
		} else if( argv(1) == "red" ) {
			DoTeamChange(COLOR_TEAM1);
		} else if( argv(1) == "blue" ) {
			DoTeamChange(COLOR_TEAM2);
		} else if( argv(1) == "yellow" ) {
			DoTeamChange(COLOR_TEAM3);
		} else if( argv(1) == "pink" ) {
			DoTeamChange(COLOR_TEAM4);
		} else if( argv(1) == "auto" ) {
			DoTeamChange(-1);
		} else {
			sprint( self, strcat( "selectteam none/red/blue/yellow/pink/auto - \"", argv(1), "\" not recognised\n" ) );
		}
	} else if(argv(0) == "ready") {
		if not(self.flags & FL_CLIENT)
			return;
		if((inWarmupStage && 0 <= g_warmup_limit) // with unlimited warmup players have to be able to restart
		   || cvar("sv_ready_restart"))
		{
			if(timeoutStatus) {
				return sprint(self, "^1You cannot reset the game while a timeout is active!\n");
			}
			
			//if(!restartAnnouncer)
			{
				if(!readyrestart_happened || cvar("sv_ready_restart_repeatable"))
				{
					self.ready = TRUE;
					bprint(self.netname, "^2 is ready\n");
					ReadyCount();
				} else {
					sprint(self, "^1game has already been restarted\n");
				}
			}
		}
	} else if(argv(0) == "maplist") {
		local float n;
		local string col;
		n = tokenize_sane(cvar_string("g_maplist"));
		sprint(self, "^7Maps in list: ");
		for(i = 0, j = 0; i < n; ++i)
		{
			if(MapInfo_CheckMap(argv(i)))
			{
				if(mod(j, 2))
					col = "^2";
				else
					col = "^3";
				sprint(self, strcat(col, argv(i), " "));
				++j;
			}
		}
		sprint(self, "\n");
	} else if(argv(0) == "lsmaps") {
		sprint(self, "^7Maps available: ");
		for(i = 0, j = 0; i < MapInfo_count; ++i)
		{
			if(MapInfo_Get_ByID(i))
			if not(MapInfo_Map_flags & MAPINFO_FLAG_HIDDEN)
			{
				if(mod(i, 2))
					col = "^2";
				else
					col = "^3";
				++j;
				sprint(self, strcat(col, MapInfo_Map_bspname, " "));
			}
		}
		sprint(self, "\n");
	} else if(argv(0) == "voice") {
		VoiceMessage(argv(1));
	} else if(argv(0) == "say") {
		if(tokens >= 2)
			Say(self, FALSE, substring(s, argv_start_index(1), argv_end_index(-1) - argv_start_index(1)));
		//clientcommand(self, formatmessage(s));
	} else if(argv(0) == "say_team") {
		if(tokens >= 2)
			Say(self, TRUE, substring(s, argv_start_index(1), argv_end_index(-1) - argv_start_index(1)));
		//clientcommand(self, formatmessage(s));
	} else if(argv(0) == "info") {
		cmd = cvar_string(strcat("sv_info_", argv(1)));
		if(cmd == "")
			sprint(self, "ERROR: unsupported info command\n");
		else
			wordwrap_sprint(cmd, 1111);
	} else if(argv(0) == "suggestmap") {
		sprint(self, strcat(MapVote_Suggest(argv(1)), "\n"));
	} else if(argv(0) == "calltimeout") {
		if not(self.flags & FL_CLIENT)
			return;
		if(cvar("sv_timeout")) {
			if(self.classname == "player") {
				if(votecalled)
					sprint(self, "^7Error: you can not call a timeout while a vote is active!\n");
				else
					evaluateTimeoutCall();
			}
			else
				sprint(self, "^7Error: only players can call a timeout!\n");
		}
	} else if(argv(0) == "resumegame") {
		if not(self.flags & FL_CLIENT)
			return;
		if(cvar("sv_timeout")) {
			evaluateResumeGame();
		}
	} else if(argv(0) == "teamstatus") {
		Score_NicePrint(self);
	} else if(argv(0) == "cvar_changes") {
		sprint(self, cvar_changes);
	} else if(argv(0) == "pointparticles") {
		if(sv_cheats && tokens == 5)
		{
			// arguments:
			//   effectname
			//   origin (0..1, on crosshair line)
			//   velocity
			//   howmany
			effectnum = particleeffectnum(argv(1));
			f = stof(argv(2));
			start = (1-f) * self.origin + f * self.cursor_trace_endpos;
			end = stov(argv(3));
			f = stof(argv(4));
			pointparticles(effectnum, start, end, f);
		}
		else
			print("Usage: sv_cheats 1; restart; cmd pointparticles effectname position(0..1) velocityvector multiplier\n");
	} else if(argv(0) == "trailparticles") {
		if(sv_cheats && tokens == 3)
		{
			// arguments:
			//   effectname
			//   shot origin vector
			effectnum = particleeffectnum(argv(1));
			W_SetupShot(self, stov(argv(2)), FALSE, FALSE, "");
			traceline(w_shotorg, w_shotorg + w_shotdir * MAX_SHOT_DISTANCE, MOVE_NORMAL, self);
			trailparticles(self, effectnum, w_shotorg, trace_endpos);
		}
		else
			print("Usage: sv_cheats 1; restart; cmd trailparticles effectname shotorigin\n");
	} else {
		//if(ctf_clientcommand())
		//	return;
		cmd = argv(0);
		/* checks not needed any more since DP has separated clientcommands and regular commands
		if(cmd != "status")
		if(cmd != "name")
		//if(cmd != "say") // handled above
		//if(cmd != "say_team") // handled above
		if(cmd != "tell")
		if(cmd != "color")
		if(cmd != "kill")
		if(cmd != "pause")
		if(cmd != "kick")
		if(cmd != "ping")
		if(cmd != "pings")
		if(cmd != "ban")
		if(cmd != "pmodel")
		if(cmd != "rate")
		if(cmd != "playermodel")
		if(cmd != "playerskin")
		if(cmd != "god") if(cmd != "notarget") if(cmd != "fly") if(cmd != "give") if(cmd != "noclip")
		{
			print("WARNING: Invalid clientcommand by ", self.netname, ": ", s, "\n");
			return;
		}
		*/
		clientcommand(self,s);
	}
}

void ReadyRestart()
{
	local entity e;

	bprint("^1Server is restarting...\n");

	VoteReset();

	// no arena, assault support yet...
	if(g_arena | g_assault | gameover | intermission_running | race_completing)
		localcmd("restart\n");

	// clear overtime
	if(checkrules_overtimeend)
		checkrules_overtimeend = 0;

	readyrestart_happened = 1;
	game_starttime = time + RESTART_COUNTDOWN;
	restart_mapalreadyrestarted = 0; //reset this var, needed when cvar sv_ready_restart_repeatable is in use

	inWarmupStage = 0; //once the game is restarted the game is in match stage

	//reset the .ready status of all players (also spectators)
	FOR_EACH_CLIENTSLOT(e)
		e.ready = 0;
	readycount = 0;
	Nagger_ReadyCounted();
	FOR_EACH_REALCLIENT(e)
	{
		msg_entity = e;
		WriteByte(MSG_ONE, SVC_TEMPENTITY);
		WriteByte(MSG_ONE, TE_CSQC_WARMUP);
		WriteByte(MSG_ONE, 0);
	}

	if(cvar("teamplay_lockonrestart") && teams_matter) {
		lockteams = 1;
		bprint("^1The teams are now locked.\n");
	}
	
	//initiate the restart-countdown-announcer entity
	restartAnnouncer = spawn();
	restartAnnouncer.think = restartAnnouncer_Think;
	restartAnnouncer.nextthink = time;
	restartAnnouncer.spawnflags = !!cvar("sv_ready_restart_after_countdown");
	
	//after a restart every players number of allowed timeouts gets reset, too
	if(cvar("sv_timeout"))
	{
		FOR_EACH_REALPLAYER(e)
			e.allowedTimeouts = cvar("sv_timeout_number");
	}

	//play the prepareforbattle sound to everyone
	play2all("announcer/robotic/prepareforbattle.wav");

	//reset map immediately if this cvar is not set
	if (!cvar("sv_ready_restart_after_countdown"))
		reset_map();

	// reset ALL scores
	Score_ClearAll();
	
	if(cvar("sv_eventlog"))
		GameLogEcho(":restart");
}

/**
 * Counts how many players are ready. If not enough players are ready, the function
 * does nothing. If all players are ready, the timelimit will be extended and the
 * restart_countdown variable is set to allow other functions like PlayerPostThink
 * to detect that the countdown is now active. If the cvar sv_ready_restart_after_countdown
 * is not set the map will be resetted.
 * 
 * Function is called after the server receives a 'ready' sign from a player.
 */
void ReadyCount()
{
	local entity e;
	local float r, p;

	r = p = 0;

	FOR_EACH_REALPLAYER(e)
	{
		p += 1;
		if(e.ready)
			r += 1;
	}

	readycount = r;

	Nagger_ReadyCounted();

	if(r) // at least one is ready
	if(r == p) // and, everyone is ready
		ReadyRestart();
}

/**
 * Shows the restart countdown for all players.
 * Plays the countdown sounds for the seconds 3, 2 1, begin for everyone.
 * Restarts the map after the countdown is over (and cvar sv_ready_restart_after_countdown
 * is set to 1).
 */
void restartAnnouncer_Think() {
	local entity plr;
	local string s;
	float f, c;
	c = game_starttime - time;
	f = floor(0.5 + c);
	if(c <= 0) { //show the "Begin" message and
		if(self.spawnflags & 1)
		{
			restart_mapalreadyrestarted = 1;
			reset_map();
		}

		FOR_EACH_REALCLIENT(plr) {
			if(plr.classname == "player") {
				s = strcat(NEWLINES, "^1Begin!");
				centerprint(plr, s);
			}
		}
		play2all("announcer/robotic/begin.wav");

		remove(self);
		return;
	}
	else {
		FOR_EACH_REALCLIENT(plr) {
			if(plr.classname == "player") {
				s = strcat(NEWLINES, "^1Game starts in ", ftos(f), " seconds");
				centerprint(plr, s);
			}
		}

		if(f <= 3) {
			play2all(strcat("announcer/robotic/", ftos(f), ".wav"));
		}
		self.nextthink = game_starttime - (f - 1);
	}
}

/**
 * Checks whether the player who calls the timeout is allowed to do so.
 * If so, it initializes the timeout countdown. It also checks whether another
 * timeout was already running at this time and reacts correspondingly.
 *
 * affected globals/fields: .allowedTimeouts, remainingTimeoutTime, remainingLeadTime,
 *                          timeoutInitiator, timeoutStatus, timeoutHandler
 *
 * This function is called when a player issues the calltimeout command.
 */
void evaluateTimeoutCall() {
	if (inWarmupStage && !g_warmup_allow_timeout)
		return sprint(self, "^7Error: You can not call a timeout in warmup-stage!\n");
	if (time < game_starttime )
		return sprint(self, "^7Error: You can not call a timeout while the map is being restarted!\n");
	if (timeoutStatus != 2) {
		//if the map uses a timelimit make sure that timeout cannot be called right before the map ends
		if (cvar("timelimit")) {
			//a timelimit was used
			local float myTl;
			myTl = cvar("timelimit");

			local float lastPossibleTimeout;
			lastPossibleTimeout = (myTl*60) - cvar("sv_timeout_leadtime") - 1;

			if (lastPossibleTimeout < time - game_starttime)
				return sprint(self, "^7Error: It is too late to call a timeout now!\n");
		}
	}
	//player may not call a timeout if he has no calls left
	if (self.allowedTimeouts < 1)
		return sprint(self, "^7Error: You already used all your timeout calls for this map!\n");
	//now all required checks are passed
	self.allowedTimeouts -= 1;
	bprint(self.netname, " ^7called a timeout (", ftos(self.allowedTimeouts), " timeouts left)!\n"); //write a bprint who started the timeout (and how many he has left)
	remainingTimeoutTime = cvar("sv_timeout_length");
	remainingLeadTime = cvar("sv_timeout_leadtime");
	timeoutInitiator = self;
	if (timeoutStatus == 0) { //if another timeout was already active, don't change its status (which was 1 or 2) to 1, only change it to 1 if no timeout was active yet
		timeoutStatus = 1;
		//create the timeout indicator which centerprints the information to all players and takes care of pausing/unpausing
		timeoutHandler = spawn();
		timeoutHandler.think = timeoutHandler_Think;
	}
	timeoutHandler.nextthink = time; //always let the entity think asap

	//inform all connected clients about the timeout call
	play2all("announcer/robotic/timeoutcalled.wav");
}

/**
 * Checks whether a player is allowed to resume the game. If he is allowed to do it,
 * and the lead time for the timeout is still active, this countdown just will be aborted (the
 * game will never be paused). Otherwise the remainingTimeoutTime will be set to the corresponding
 * value of the cvar sv_timeout_resumetime.
 *
 * This function is called when a player issues the resumegame command.
 */
void evaluateResumeGame() {
	if (!timeoutStatus)
		return sprint(self, "^7Error: There is no active timeout which could be aborted!\n");
	if (self != timeoutInitiator)
		return sprint(self, "^7Error: You may not abort the active timeout. Only the player who called it can do that!\n");
	if (timeoutStatus == 1) {
		remainingTimeoutTime = timeoutStatus = 0;
		timeoutHandler.nextthink = time; //timeoutHandler has to take care of it immediately
		bprint(strcat("^7The timeout was aborted by ", self.netname, " !\n"));
	}
	else if (timeoutStatus == 2) {
		//only shorten the remainingTimeoutTime if it makes sense
		if( remainingTimeoutTime > (cvar("sv_timeout_resumetime") + 1) ) {
			bprint(strcat("^1Attention: ^7", self.netname, " resumed the game! Prepare for battle!\n"));
			remainingTimeoutTime = cvar("sv_timeout_resumetime");
			timeoutHandler.nextthink = time; //timeoutHandler has to take care of it immediately
		}
		else
			sprint(self, "^7Error: Your resumegame call was discarded!\n");

	}
}
