void() spawnfunc_info_player_deathmatch; // needed for the other spawnpoints
void() spawnpoint_use;
string ColoredTeamName(float t);

float RandomSelection_totalweight;
float RandomSelection_best_priority;
entity RandomSelection_chosen_ent;
float RandomSelection_chosen_float;
void RandomSelection_Init()
{
	RandomSelection_totalweight = 0;
	RandomSelection_chosen_ent = world;
	RandomSelection_chosen_float = 0;
	RandomSelection_best_priority = -1;
}
void RandomSelection_Add(entity e, float f, float weight, float priority)
{
	if(priority > RandomSelection_best_priority)
	{
		RandomSelection_best_priority = priority;
		RandomSelection_chosen_ent = e;
		RandomSelection_chosen_float = f;
		RandomSelection_totalweight = weight;
	}
	else if(priority == RandomSelection_best_priority)
	{
		RandomSelection_totalweight += weight;
		if(random() * RandomSelection_totalweight <= weight)
		{
			RandomSelection_chosen_ent = e;
			RandomSelection_chosen_float = f;
		}
	}
}

float DistributeEvenly_amount;
float DistributeEvenly_totalweight;
void DistributeEvenly_Init(float amount, float totalweight)
{
	if(DistributeEvenly_amount)
	{
		dprint("DistributeEvenly_Init: UNFINISHED DISTRIBUTION (", ftos(DistributeEvenly_amount), " for ");
		dprint(ftos(DistributeEvenly_totalweight), " left!)\n");
	}
	if(totalweight == 0)
		DistributeEvenly_amount = 0;
	else
		DistributeEvenly_amount = amount;
	DistributeEvenly_totalweight = totalweight;
}
float DistributeEvenly_Get(float weight)
{
	float f;
	if(weight <= 0)
		return 0;
	f = floor(0.5 + DistributeEvenly_amount * weight / DistributeEvenly_totalweight);
	DistributeEvenly_totalweight -= weight;
	DistributeEvenly_amount -= f;
	return f;
}

void move_out_of_solid_expand(entity e, vector by)
{
	float eps = 0.0625;
	tracebox(e.origin, e.mins - '1 1 1' * eps, e.maxs + '1 1 1' * eps, e.origin + by, MOVE_WORLDONLY, e);
	if(trace_startsolid)
		return;
	if(trace_fraction < 1)
	{
		// hit something
		// adjust origin in the other direction...
		e.origin = e.origin - by * (1 - trace_fraction);
	}
}

void move_out_of_solid(entity e)
{
	vector o, m0, m1;

	o = e.origin;
	traceline(o, o, MOVE_WORLDONLY, e);
	if(trace_startsolid)
	{
		dprint("origin is in solid too! (", vtos(o), ")");
		return;
	}

	tracebox(o, e.mins, e.maxs, o, MOVE_WORLDONLY, e);
	if(!trace_startsolid)
		return;

	m0 = e.mins;
	m1 = e.maxs;
	e.mins = '0 0 0';
	e.maxs = '0 0 0';
	move_out_of_solid_expand(e, '1 0 0' * m0_x); e.mins_x = m0_x;
	move_out_of_solid_expand(e, '1 0 0' * m1_x); e.maxs_x = m1_x;
	move_out_of_solid_expand(e, '0 1 0' * m0_y); e.mins_y = m0_y;
	move_out_of_solid_expand(e, '0 1 0' * m1_y); e.maxs_y = m1_y;
	move_out_of_solid_expand(e, '0 0 1' * m0_z); e.mins_z = m0_z;
	move_out_of_solid_expand(e, '0 0 1' * m1_z); e.maxs_z = m1_z;
	setorigin(e, e.origin);

	tracebox(e.origin, e.mins, e.maxs, e.origin, MOVE_WORLDONLY, e);
	if(trace_startsolid)
	{
		dprint("could not get out of solid (", vtos(o), ")\n");
		return;
	}
}

string STR_PLAYER = "player";
string STR_SPECTATOR = "spectator";
string STR_OBSERVER = "observer";

#if 0
#define FOR_EACH_CLIENT(v) for(v = world; (v = findflags(v, flags, FL_CLIENT)) != world; )
#define FOR_EACH_REALCLIENT(v) FOR_EACH_CLIENT(v) if(clienttype(v) == CLIENTTYPE_REAL)
#define FOR_EACH_PLAYER(v) for(v = world; (v = find(v, classname, STR_PLAYER)) != world; )
#define FOR_EACH_REALPLAYER(v) FOR_EACH_PLAYER(v) if(clienttype(v) == CLIENTTYPE_REAL)
#else
#define FOR_EACH_CLIENTSLOT(v) for(v = world; (v = nextent(v)) && (num_for_edict(v) <= maxclients); )
#define FOR_EACH_CLIENT(v) FOR_EACH_CLIENTSLOT(v) if(v.flags & FL_CLIENT)
#define FOR_EACH_REALCLIENT(v) FOR_EACH_CLIENT(v) if(clienttype(v) == CLIENTTYPE_REAL)
#define FOR_EACH_PLAYER(v) FOR_EACH_CLIENT(v) if(v.classname == STR_PLAYER)
#define FOR_EACH_REALPLAYER(v) FOR_EACH_REALCLIENT(v) if(v.classname == STR_PLAYER)
#endif

// copies a string to a tempstring (so one can strunzone it)
string strcat1(string s) = #115; // FRIK_FILE

float logfile_open;
float logfile;

void bcenterprint(string s)
{
	// TODO replace by MSG_ALL (would show it to spectators too, though)?
	entity head;
	FOR_EACH_PLAYER(head)
		if(clienttype(head) == CLIENTTYPE_REAL)
			centerprint(head, s);
}

void ServerConsoleEcho(string s, float check_dangerous)
{
	local string ch;
	if (checkextension("DP_SV_PRINT"))
		print(s, "\n");
	else
	{
		localcmd("echo \"");
		if(check_dangerous)
		{
			while(strlen(s))
			{
				ch = substring(s, 0, 1);
				if(ch != "\"" && ch != "\r" && ch != "\n")
					localcmd(ch);
				s = substring(s, 1, strlen(s) - 1);
			}
		}
		else
		{
			localcmd(s);
		}
		localcmd("\"\n");
	}
}

void GameLogEcho(string s, float check_dangerous)
{
	string fn;
	float matches;

	if(cvar("sv_eventlog_files"))
	{
		if(!logfile_open)
		{
			logfile_open = TRUE;
			matches = cvar("sv_eventlog_files_counter") + 1;
			cvar_set("sv_eventlog_files_counter", ftos(matches));
			fn = ftos(matches);
			if(strlen(fn) < 8)
				fn = strcat(substring("00000000", 0, 8 - strlen(fn)), fn);
			fn = strcat(cvar_string("sv_eventlog_files_nameprefix"), fn, cvar_string("sv_eventlog_files_namesuffix"));
			logfile = fopen(fn, FILE_APPEND);
			fputs(logfile, ":logversion:2\n");
		}
		if(logfile >= 0)
		{
			if(cvar("sv_eventlog_files_timestamps"))
				fputs(logfile, strcat(":time:", strftime(TRUE, "%Y-%m-%d %H:%M:%S", "\n", s, "\n")));
			else
				fputs(logfile, strcat(s, "\n"));
		}
	}
	if(cvar("sv_eventlog_console"))
	{
		ServerConsoleEcho(s, check_dangerous);
	}
}

void GameLogInit()
{
	logfile_open = 0;
	// will be opened later
}

void GameLogClose()
{
	if(logfile_open && logfile >= 0)
	{
		fclose(logfile);
		logfile = -1;
	}
}

float spawnpoint_nag;
void relocate_spawnpoint()
{
	// nudge off the floor
	setorigin(self, self.origin + '0 0 1');

	tracebox(self.origin, PL_MIN, PL_MAX, self.origin, TRUE, self);
	if (trace_startsolid)
	{
		vector o;
		o = self.origin;
		self.mins = PL_MIN;
		self.maxs = PL_MAX;
		move_out_of_solid(self);
		print("^1NOTE: this map needs FIXING. Spawnpoint at ", vtos(o - '0 0 1'));
		print(" needs to be moved out of solid, e.g. by '", ftos(self.origin_x - o_x));
		print(" ", ftos(self.origin_y - o_y));
		print(" ", ftos(self.origin_z - o_z), "'\n");
		if(cvar("g_spawnpoints_auto_move_out_of_solid"))
		{
			if(!spawnpoint_nag)
				print("\{1}^1NOTE: this map needs FIXING (it contains spawnpoints in solid, see server log)\n");
			spawnpoint_nag = 1;
		}
		else
		{
			self.origin = o;
			self.mins = self.maxs = '0 0 0';
			objerror("player spawn point in solid, mapper sucks!\n");
			return;
		}
	}

	if(cvar("g_spawnpoints_autodrop"))
	{
		setsize(self, PL_MIN, PL_MAX);
		droptofloor();
	}

	self.use = spawnpoint_use;
	self.team_saved = self.team;
	if(!self.cnt)
		self.cnt = 1;

	if(g_ctf || g_assault || g_onslaught || g_domination)
	if(self.team)
		have_team_spawns = 1;

	if(cvar("r_showbboxes"))
	{
		// show where spawnpoints point at too
		makevectors(self.angles);
		entity e;
		e = spawn();
		e.classname = "info_player_foo";
		setorigin(e, self.origin + v_forward * 24);
		setsize(e, '-8 -8 -8', '8 8 8');
		e.solid = SOLID_TRIGGER;
	}
}

#define strstr strstrofs
/*
// NOTE: DO NOT USE THIS FUNCTION TOO OFTEN.
// IT WILL MOST PROBABLY DESTROY _ALL_ OTHER TEMP
// STRINGS AND TAKE QUITE LONG. haystack and needle MUST
// BE CONSTANT OR strzoneD!
float strstr(string haystack, string needle, float offset)
{
	float len, endpos;
	string found;
	len = strlen(needle);
	endpos = strlen(haystack) - len;
	while(offset <= endpos)
	{
		found = substring(haystack, offset, len);
		if(found == needle)
			return offset;
		offset = offset + 1;
	}
	return -1;
}
*/

float NUM_NEAREST_ENTITIES = 4;
entity nearest_entity[NUM_NEAREST_ENTITIES];
float nearest_length[NUM_NEAREST_ENTITIES];
entity findnearest(vector point, .string field, string value, vector axismod)
{
	entity localhead;
	float i;
	float j;
	float len;
	vector dist;

	float num_nearest;
	num_nearest = 0;

	localhead = find(world, field, value);
	while(localhead)
	{
		if((localhead.items == IT_KEY1 || localhead.items == IT_KEY2) && localhead.target == "###item###")
			dist = localhead.oldorigin;
		else
			dist = localhead.origin;
		dist = dist - point;
		dist = dist_x * axismod_x * '1 0 0' + dist_y * axismod_y * '0 1 0' + dist_z * axismod_z * '0 0 1';
		len = vlen(dist);

		for(i = 0; i < num_nearest; ++i)
		{
			if(len < nearest_length[i])
				break;
		}

		// now i tells us where to insert at
		//   INSERTION SORT! YOU'VE SEEN IT! RUN!
		if(i < NUM_NEAREST_ENTITIES)
		{
			for(j = NUM_NEAREST_ENTITIES - 1; j >= i; --j)
			{
				nearest_length[j + 1] = nearest_length[j];
				nearest_entity[j + 1] = nearest_entity[j];
			}
			nearest_length[i] = len;
			nearest_entity[i] = localhead;
			if(num_nearest < NUM_NEAREST_ENTITIES)
				num_nearest = num_nearest + 1;
		}

		localhead = find(localhead, field, value);
	}

	// now use the first one from our list that we can see
	for(i = 0; i < num_nearest; ++i)
	{
		traceline(point, nearest_entity[i].origin, TRUE, world);
		if(trace_fraction == 1)
		{
			if(i != 0)
			{
				dprint("Nearest point (");
				dprint(nearest_entity[0].netname);
				dprint(") is not visible, using a visible one.\n");
			}
			return nearest_entity[i];
		}
	}

	if(num_nearest == 0)
		return world;

	dprint("Not seeing any location point, using nearest as fallback.\n");
	/* DEBUGGING CODE:
	dprint("Candidates were: ");
	for(j = 0; j < num_nearest; ++j)
	{
		if(j != 0)
			dprint(", ");
		dprint(nearest_entity[j].netname);
	}
	dprint("\n");
	*/

	return nearest_entity[0];
}

void spawnfunc_target_location()
{
	self.classname = "target_location";
	// location name in netname
	// eventually support: count, teamgame selectors, line of sight?
};

void spawnfunc_info_location()
{
	self.classname = "target_location";
	self.message = self.netname;
};

string NearestLocation(vector p)
{
	entity loc;
	string ret;
	ret = "somewhere";
	loc = findnearest(p, classname, "target_location", '1 1 1');
	if(loc)
	{
		ret = loc.message;
	}
	else
	{
		loc = findnearest(p, target, "###item###", '1 1 4');
		if(loc)
			ret = loc.netname;
	}
	return ret;
}

string formatmessage(string msg)
{
	float p;
	float n;
	string msg_save;
	string escape;
	string replacement;
	msg_save = strzone(msg);
	p = 0;
	n = 7;
	while(1)
	{
		if(n < 1)
			break; // too many replacements
		n = n - 1;
		p = strstr(msg_save, "%", p); // NOTE: this destroys msg as it's a tempstring!
		if(p < 0)
			break;
		replacement = substring(msg_save, p, 2);
		escape = substring(msg_save, p + 1, 1);
		if(escape == "%")
			replacement = "%";
		else if(escape == "a")
			replacement = ftos(floor(self.armorvalue));
		else if(escape == "h")
			replacement = ftos(floor(self.health));
		else if(escape == "l")
			replacement = NearestLocation(self.origin);
		else if(escape == "y")
			replacement = NearestLocation(self.cursor_trace_endpos);
		else if(escape == "d")
			replacement = NearestLocation(self.death_origin);
		else if(escape == "w")
		{
			float wep;
			wep = self.weapon;
			if(!wep)
				wep = self.switchweapon;
			if(!wep)
				wep = self.cnt;
			replacement = W_Name(wep);
		}
		else if(escape == "W")
		{
			if(self.items & IT_SHELLS) replacement = "shells";
			else if(self.items & IT_NAILS) replacement = "bullets";
			else if(self.items & IT_ROCKETS) replacement = "rockets";
			else if(self.items & IT_CELLS) replacement = "cells";
			else replacement = "batteries"; // ;)
		}
		else if(escape == "x")
		{
			replacement = self.cursor_trace_ent.netname;
			if(!replacement || !self.cursor_trace_ent)
				replacement = "nothing";
		}
		else if(escape == "p")
		{
			if(self.last_selected_player)
				replacement = self.last_selected_player.netname;
			else
				replacement = "(nobody)";
		}
		msg = strcat(substring(msg_save, 0, p), replacement);
		msg = strcat(msg, substring(msg_save, p+2, strlen(msg_save) - (p+2)));
		strunzone(msg_save);
		msg_save = strzone(msg);
		p = p + 2;
	}
	msg = strcat(msg_save, "");
	strunzone(msg_save);
	return msg;
}

/*
=============
GetCvars
=============
Called with:
  0:  sends the request
  >0: receives a cvar from name=argv(f) value=argv(f+1)
*/
void GetCvars_handleString(float f, .string field, string name)
{
	if(f < 0)
	{
		if(self.field)
			strunzone(self.field);
	}
	else if(f > 0)
	{
		if(argv(f) == name)
		{
			if(self.field)
				strunzone(self.field);
			self.field = strzone(argv(f + 1));
		}
	}
	else
		stuffcmd(self, strcat("sendcvar ", name, "\n"));
}
void GetCvars_handleFloat(float f, .float field, string name)
{
	if(f < 0)
	{
	}
	else if(f > 0)
	{
		if(argv(f) == name)
			self.field = stof(argv(f + 1));
	}
	else
		stuffcmd(self, strcat("sendcvar ", name, "\n"));
}
void GetCvars(float f)
{
	GetCvars_handleFloat(f, autoswitch, "cl_autoswitch");
	GetCvars_handleFloat(f, cvar_cl_hidewaypoints, "cl_hidewaypoints");
	GetCvars_handleFloat(f, cvar_cl_zoomfactor, "cl_zoomfactor");
	GetCvars_handleFloat(f, cvar_cl_zoomspeed, "cl_zoomspeed");
	GetCvars_handleFloat(f, cvar_cl_playerdetailreduction, "cl_playerdetailreduction");
	GetCvars_handleFloat(f, cvar_cl_nogibs, "cl_nogibs");
	GetCvars_handleFloat(f, cvar_scr_centertime, "scr_centertime");
	GetCvars_handleFloat(f, cvar_cl_shownames, "cl_shownames");
	GetCvars_handleString(f, cvar_g_nexuizversion, "g_nexuizversion");
	GetCvars_handleFloat(f, cvar_cl_handicap, "cl_handicap");
}

float fexists(string f)
{
	float fh;
	fh = fopen(f, FILE_READ);
	if(fh < 0)
		return FALSE;
	fclose(fh);
	return TRUE;
}

void backtrace(string msg)
{
	float dev;
	dev = cvar("developer");
	cvar_set("developer", "1");
	dprint("\n");
	dprint("--- CUT HERE ---\nWARNING: ");
	dprint(msg);
	dprint("\n");
	remove(world); // isn't there any better way to cause a backtrace?
	dprint("\n--- CUT UNTIL HERE ---\n");
	cvar_set("developer", ftos(dev));
}

string Team_ColorCode(float teamid)
{
	if(teamid == COLOR_TEAM1)
		return "^1";
	else if(teamid == COLOR_TEAM2)
		return "^4";
	else if(teamid == COLOR_TEAM3)
		return "^3";
	else if(teamid == COLOR_TEAM4)
		return "^6";
	else
		return "^7";
}
string Team_ColorName(float t)
{
	// fixme: Search for team entities and get their .netname's!
	if(t == COLOR_TEAM1)
		return "Red";
	if(t == COLOR_TEAM2)
		return "Blue";
	if(t == COLOR_TEAM3)
		return "Yellow";
	if(t == COLOR_TEAM4)
		return "Pink";
	return "Neutral";
}
string Team_ColorNameLowerCase(float t)
{
	// fixme: Search for team entities and get their .netname's!
	if(t == COLOR_TEAM1)
		return "red";
	if(t == COLOR_TEAM2)
		return "blue";
	if(t == COLOR_TEAM3)
		return "yellow";
	if(t == COLOR_TEAM4)
		return "pink";
	return "neutral";
}

#define CENTERPRIO_POINT 1
#define CENTERPRIO_SPAM 2
#define CENTERPRIO_REBALANCE 2
#define CENTERPRIO_VOTE 4
#define CENTERPRIO_NORMAL 5
#define CENTERPRIO_MAPVOTE 9
#define CENTERPRIO_IDLEKICK 50
#define CENTERPRIO_ADMIN 99
.float centerprint_priority;
.float centerprint_expires;
void centerprint_atprio(entity e, float prio, string s)
{
	if(intermission_running)
		if(prio < CENTERPRIO_MAPVOTE)
			return;
	if(time > e.centerprint_expires)
		e.centerprint_priority = 0;
	if(prio >= e.centerprint_priority)
	{
		e.centerprint_priority = prio;
		if(timeoutStatus == 2)
			e.centerprint_expires = time + (e.cvar_scr_centertime * TIMEOUT_SLOWMO_VALUE);
		else
			e.centerprint_expires = time + e.cvar_scr_centertime;
		centerprint_builtin(e, s);
	}
}
void centerprint_expire(entity e, float prio)
{
	if(prio == e.centerprint_priority)
	{
		e.centerprint_priority = 0;
		centerprint_builtin(e, "");
	}
}
void centerprint(entity e, string s)
{
	centerprint_atprio(e, CENTERPRIO_NORMAL, s);
}

void VoteNag();

// decolorizes and team colors the player name when needed
string playername(entity p)
{
	string t;
	if(teams_matter && !intermission_running && p.classname == "player")
	{
		t = Team_ColorCode(p.team);
		return strcat(t, strdecolorize(p.netname));
	}
	else
		return p.netname;
}

vector randompos(vector m1, vector m2)
{
	local vector v;
	m2 = m2 - m1;
	v_x = m2_x * random() + m1_x;
	v_y = m2_y * random() + m1_y;
	v_z = m2_z * random() + m1_z;
	return  v;
};

// requires that m2>m1 in all coordinates, and that m4>m3
float boxesoverlap(vector m1, vector m2, vector m3, vector m4) {return m2_x >= m3_x && m1_x <= m4_x && m2_y >= m3_y && m1_y <= m4_y && m2_z >= m3_z && m1_z <= m4_z;};

// requires the same, but is a stronger condition
float boxinsidebox(vector smins, vector smaxs, vector bmins, vector bmaxs) {return smins_x >= bmins_x && smaxs_x <= bmaxs_x && smins_y >= bmins_y && smaxs_y <= bmaxs_y && smins_z >= bmins_z && smaxs_z <= bmaxs_z;};

float g_pickup_shells;
float g_pickup_shells_max;
float g_pickup_nails;
float g_pickup_nails_max;
float g_pickup_rockets;
float g_pickup_rockets_max;
float g_pickup_cells;
float g_pickup_cells_max;
float g_pickup_armorsmall;
float g_pickup_armorsmall_max;
float g_pickup_armormedium;
float g_pickup_armormedium_max;
float g_pickup_armorlarge;
float g_pickup_armorlarge_max;
float g_pickup_healthsmall;
float g_pickup_healthsmall_max;
float g_pickup_healthmedium;
float g_pickup_healthmedium_max;
float g_pickup_healthlarge;
float g_pickup_healthlarge_max;
float g_pickup_healthmega;
float g_pickup_healthmega_max;

float start_items;
float start_switchweapon;
float start_ammo_shells;
float start_ammo_nails;
float start_ammo_rockets;
float start_ammo_cells;
float start_health;
float start_armorvalue;

void readlevelcvars(void)
{
	sv_cheats = cvar("sv_cheats");
	sv_gentle = cvar("sv_gentle");
	sv_foginterval = cvar("sv_foginterval");
	g_cloaked = cvar("g_cloaked");
	g_jump_grunt = cvar("g_jump_grunt");
	g_footsteps = cvar("g_footsteps");
	g_grappling_hook = cvar("g_grappling_hook");
	g_instagib = cvar("g_instagib");
	g_laserguided_missile = cvar("g_laserguided_missile");
	g_midair = cvar("g_midair");
	g_minstagib = cvar("g_minstagib");
	g_nixnex = cvar("g_nixnex");
	g_nixnex_with_laser = cvar("g_nixnex_with_laser");
	g_norecoil = cvar("g_norecoil");
	g_rocketarena = cvar("g_rocketarena");
	g_vampire = cvar("g_vampire");
	g_tourney = cvar("g_tourney");
	sv_maxidle = cvar("sv_maxidle");
	sv_maxidle_spectatorsareidle = cvar("sv_maxidle_spectatorsareidle");
	sv_pogostick = cvar("sv_pogostick");
	sv_doublejump = cvar("sv_doublejump");

	if(g_instagib) g_minstagib = g_nixnex = g_rocketarena = 0;
	if(g_minstagib) g_nixnex = g_rocketarena = 0;
	if(g_nixnex) g_rocketarena = 0;

	g_pickup_shells                    = cvar("g_pickup_shells");
	g_pickup_shells_max                = cvar("g_pickup_shells_max");
	g_pickup_nails                     = cvar("g_pickup_nails");
	g_pickup_nails_max                 = cvar("g_pickup_nails_max");
	g_pickup_rockets                   = cvar("g_pickup_rockets");
	g_pickup_rockets_max               = cvar("g_pickup_rockets_max");
	g_pickup_cells                     = cvar("g_pickup_cells");
	g_pickup_cells_max                 = cvar("g_pickup_cells_max");
	g_pickup_armorsmall                = cvar("g_pickup_armorsmall");
	g_pickup_armorsmall_max            = cvar("g_pickup_armorsmall_max");
	g_pickup_armormedium               = cvar("g_pickup_armormedium");
	g_pickup_armormedium_max           = cvar("g_pickup_armormedium_max");
	g_pickup_armorlarge                = cvar("g_pickup_armorlarge");
	g_pickup_armorlarge_max            = cvar("g_pickup_armorlarge_max");
	g_pickup_healthsmall               = cvar("g_pickup_healthsmall");
	g_pickup_healthsmall_max           = cvar("g_pickup_healthsmall_max");
	g_pickup_healthmedium              = cvar("g_pickup_healthmedium");
	g_pickup_healthmedium_max          = cvar("g_pickup_healthmedium_max");
	g_pickup_healthlarge               = cvar("g_pickup_healthlarge");
	g_pickup_healthlarge_max           = cvar("g_pickup_healthlarge_max");
	g_pickup_healthmega                = cvar("g_pickup_healthmega");
	g_pickup_healthmega_max            = cvar("g_pickup_healthmega_max");

	// initialize starting values for players
	start_items = 0;
	start_switchweapon = 0;
	start_ammo_shells = 0;
	start_ammo_nails = 0;
	start_ammo_rockets = 0;
	start_ammo_cells = 0;
	start_health = cvar("g_balance_health_start");
	start_armorvalue = cvar("g_balance_armor_start");

	if(g_instagib)
	{
		start_items = IT_NEX;
		start_switchweapon = WEP_NEX;
		weapon_action(start_switchweapon, WR_PRECACHE);
		start_ammo_cells = 999;
	}
	else if(g_rocketarena)
	{
		start_items = IT_ROCKET_LAUNCHER;
		start_switchweapon = WEP_ROCKET_LAUNCHER;
		weapon_action(start_switchweapon, WR_PRECACHE);
		start_ammo_rockets = 999;
	}
	else if(g_nixnex)
	{
		start_items = 0;
		// will be done later
	}
	else if(g_minstagib)
	{
		start_health = 100;
		start_armorvalue = 0;
		start_items = IT_NEX;
		start_switchweapon = WEP_NEX;
		weapon_action(start_switchweapon, WR_PRECACHE);
		start_ammo_cells = cvar("g_minstagib_ammo_start");
		g_minstagib_invis_alpha = cvar("g_minstagib_invis_alpha");
	}
	else
	{
		if(g_lms)
		{
			start_ammo_shells = cvar("g_lms_start_ammo_shells");
			start_ammo_nails = cvar("g_lms_start_ammo_nails");
			start_ammo_rockets = cvar("g_lms_start_ammo_rockets");
			start_ammo_cells = cvar("g_lms_start_ammo_cells");
			start_health = cvar("g_lms_start_health");
			start_armorvalue = cvar("g_lms_start_armor");
		}
		else if(g_tourney) {
			start_ammo_shells = cvar("g_tourney_start_ammo_shells");
			start_ammo_nails = cvar("g_tourney_start_ammo_nails");
			start_ammo_rockets = cvar("g_tourney_start_ammo_rockets");
			start_ammo_cells = cvar("g_tourney_start_ammo_cells");
			start_health = cvar("g_tourney_start_health");
			start_armorvalue = cvar("g_tourney_start_armor");
		}
		else if (cvar("g_use_ammunition")) {
			start_ammo_shells = cvar("g_start_ammo_shells");
			start_ammo_nails = cvar("g_start_ammo_nails");
			start_ammo_rockets = cvar("g_start_ammo_rockets");
			start_ammo_cells = cvar("g_start_ammo_cells");
		} else {
			start_ammo_shells = cvar("g_pickup_shells_max");
			start_ammo_nails = cvar("g_pickup_nails_max");
			start_ammo_rockets = cvar("g_pickup_rockets_max");
			start_ammo_cells = cvar("g_pickup_cells_max");
		}

		if (cvar("g_start_weapon_laser") || g_lms)
		{
			start_items = start_items | IT_LASER;
			start_switchweapon = WEP_LASER;
			weapon_action(start_switchweapon, WR_PRECACHE);
		}
		if (cvar("g_start_weapon_shotgun") || g_lms)
		{
			start_items = start_items | IT_SHOTGUN;
			start_switchweapon = WEP_SHOTGUN;
			weapon_action(start_switchweapon, WR_PRECACHE);
		}
		if (cvar("g_start_weapon_uzi") || g_lms || g_tourney)
		{
			start_items = start_items | IT_UZI;
			start_switchweapon = WEP_UZI;
			weapon_action(start_switchweapon, WR_PRECACHE);
		}
		if (cvar("g_start_weapon_grenadelauncher") || g_lms || g_tourney)
		{
			start_items = start_items | IT_GRENADE_LAUNCHER;
			start_switchweapon = WEP_GRENADE_LAUNCHER;
			weapon_action(start_switchweapon, WR_PRECACHE);
		}
		if (cvar("g_start_weapon_electro") || g_lms || g_tourney)
		{
			start_items = start_items | IT_ELECTRO;
			start_switchweapon = WEP_ELECTRO;
			weapon_action(start_switchweapon, WR_PRECACHE);
		}
		if (cvar("g_start_weapon_crylink") || g_lms || g_tourney)
		{
			start_items = start_items | IT_CRYLINK;
			start_switchweapon = WEP_CRYLINK;
			weapon_action(start_switchweapon, WR_PRECACHE);
		}
		if (cvar("g_start_weapon_nex") || g_lms || g_tourney)
		{
			start_items = start_items | IT_NEX;
			start_switchweapon = WEP_NEX;
			weapon_action(start_switchweapon, WR_PRECACHE);
		}
		if (cvar("g_start_weapon_hagar") || g_lms || g_tourney)
		{
			start_items = start_items | IT_HAGAR;
			start_switchweapon = WEP_HAGAR;
			weapon_action(start_switchweapon, WR_PRECACHE);
		}
		if (cvar("g_start_weapon_rocketlauncher") || g_lms || g_tourney)
		{
			start_items = start_items | IT_ROCKET_LAUNCHER;
			start_switchweapon = WEP_ROCKET_LAUNCHER;
			weapon_action(start_switchweapon, WR_PRECACHE);
		}
	}
}

/*
// TODO sound pack system
string soundpack;

string precache_sound_builtin (string s) = #19;
void(entity e, float chan, string samp, float vol, float atten) sound_builtin = #8;
string precache_sound(string s)
{
	return precache_sound_builtin(strcat(soundpack, s));
}
void play2(entity e, string filename)
{
	stuffcmd(e, strcat("play2 ", soundpack, filename, "\n"));
}
void sound(entity e, float chan, string samp, float vol, float atten)
{
	sound_builtin(e, chan, strcat(soundpack, samp), vol, atten);
}
*/

// Sound functions
string precache_sound (string s) = #19;
void(entity e, float chan, string samp, float vol, float atten) sound = #8;
float precache_sound_index (string s) = #19;

void soundtoat(float dest, entity e, vector o, float chan, string samp, float vol, float atten)
{
	WriteByte(dest, 6);
	WriteByte(dest, 27); // all bits except SND_LOOPING
	WriteByte(dest, vol * 255);
	WriteByte(dest, atten * 64);
	WriteEntity(dest, e);
	WriteByte(dest, chan);
	WriteShort(dest, precache_sound_index(samp));
	WriteCoord(dest, o_x);
	WriteCoord(dest, o_y);
	WriteCoord(dest, o_z);
}
void soundto(float dest, entity e, float chan, string samp, float vol, float atten)
{
	vector o;
	o = e.origin + 0.5 * (e.mins + e.maxs);
	soundtoat(dest, e, o, chan, samp, vol, atten);
}
void soundat(entity e, vector o, float chan, string samp, float vol, float atten)
{
	soundtoat(MSG_BROADCAST, e, o, chan, samp, vol, atten);
}

void play2(entity e, string filename)
{
	//stuffcmd(e, strcat("play2 ", filename, "\n"));
	msg_entity = e;
	soundtoat(MSG_ONE, world, '0 0 0', CHAN_AUTO, filename, VOL_BASE, ATTN_NONE);
}

.float announcetime;
void announce(entity player, string msg)
{
	if(time > player.announcetime)
	if(clienttype(player) == CLIENTTYPE_REAL)
	{
		player.announcetime = time + 0.3;
		play2(player, msg);
	}
}

void play2team(float t, string filename)
{
	local entity head;
	FOR_EACH_REALPLAYER(head)
	{
		if (head.team == t)
			play2(head, filename);
	}
}

void play2all(string samp)
{
	sound(world, CHAN_AUTO, samp, VOL_BASE, ATTN_NONE);
}

void PrecachePlayerSounds(string f);
void precache_all_models(string pattern)
{
	float globhandle, i, n;
	string f;

	globhandle = search_begin(pattern, TRUE, FALSE);
	if(globhandle < 0)
		return;
	n = search_getsize(globhandle);
	for(i = 0; i < n; ++i)
	{
		//print(search_getfilename(globhandle, i), "\n");
		f = search_getfilename(globhandle, i);
		precache_model(f);
		PrecachePlayerSounds(strcat(f, ".sounds"));
	}
	search_end(globhandle);
}

void precache()
{
	// gamemode related things
	precache_model ("models/misc/chatbubble.spr");
	precache_model ("models/misc/teambubble.spr");
	if (g_runematch)
	{
		precache_model ("models/runematch/curse.mdl");
		precache_model ("models/runematch/rune.mdl");
	}

	// Precache all player models if desired
	if (cvar("sv_precacheplayermodels"))
	{
		PrecachePlayerSounds("sound/player/default.sounds");
		precache_all_models("models/player/*.zym");
		precache_all_models("models/player/*.dpm");
		precache_all_models("models/player/*.md3");
		precache_all_models("models/player/*.psk");
		//precache_model("models/player/carni.zym");
		//precache_model("models/player/crash.zym");
		//precache_model("models/player/grunt.zym");
		//precache_model("models/player/headhunter.zym");
		//precache_model("models/player/insurrectionist.zym");
		//precache_model("models/player/jeandarc.zym");
		//precache_model("models/player/lurk.zym");
		//precache_model("models/player/lycanthrope.zym");
		//precache_model("models/player/marine.zym");
		//precache_model("models/player/nexus.zym");
		//precache_model("models/player/pyria.zym");
		//precache_model("models/player/shock.zym");
		//precache_model("models/player/skadi.zym");
		//precache_model("models/player/specop.zym");
		//precache_model("models/player/visitant.zym");
	}

	if (g_footsteps)
	{
		PrecacheGlobalSound((globalsound_step = "misc/footstep0 6"));
		PrecacheGlobalSound((globalsound_metalstep = "misc/metalfootstep0 6"));
	}

	// gore and miscellaneous sounds
	//precache_sound ("misc/h2ohit.wav");
	precache_model ("models/gibs/bloodyskull.md3");
	precache_model ("models/gibs/chunk.mdl");
	precache_model ("models/gibs/eye.md3");
	precache_model ("models/gibs/gib1.md3");
	precache_model ("models/gibs/gib2.md3");
	precache_model ("models/gibs/gib3.md3");
	precache_model ("models/gibs/gib4.md3");
	precache_model ("models/gibs/gib5.md3");
	precache_model ("models/gibs/gib6.md3");
	precache_model ("models/gibs/smallchest.md3");
	precache_model ("models/gibs/chest.md3");
	precache_model ("models/gibs/arm.md3");
	precache_model ("models/gibs/leg1.md3");
	precache_model ("models/gibs/leg2.md3");
	precache_model ("models/hook.md3");
	precache_sound ("misc/armorimpact.wav");
	precache_sound ("misc/bodyimpact1.wav");
	precache_sound ("misc/bodyimpact2.wav");
	precache_sound ("misc/gib.wav");
	precache_sound ("misc/gib_splat01.wav");
	precache_sound ("misc/gib_splat02.wav");
	precache_sound ("misc/gib_splat03.wav");
	precache_sound ("misc/gib_splat04.wav");
	precache_sound ("misc/hit.wav");
	PrecacheGlobalSound((globalsound_fall = "misc/hitground 4"));
	PrecacheGlobalSound((globalsound_metalfall = "misc/metalhitground 4"));
	precache_sound ("misc/null.wav");
	precache_sound ("misc/spawn.wav");
	precache_sound ("misc/talk.wav");
	precache_sound ("misc/teleport.wav");
	precache_sound ("player/lava.wav");
	precache_sound ("player/slime.wav");

	// announcer sounds - male
	//precache_sound ("announcer/male/electrobitch.wav");
	precache_sound ("announcer/male/03kills.wav");
	precache_sound ("announcer/male/05kills.wav");
	precache_sound ("announcer/male/10kills.wav");
	precache_sound ("announcer/male/15kills.wav");
	precache_sound ("announcer/male/20kills.wav");
	precache_sound ("announcer/male/25kills.wav");
	precache_sound ("announcer/male/30kills.wav");
	precache_sound ("announcer/male/botlike.wav");
	precache_sound ("announcer/male/yoda.wav");

	// announcer sounds - robotic
	precache_sound ("announcer/robotic/prepareforbattle.wav");
	precache_sound ("announcer/robotic/begin.wav");
	precache_sound ("announcer/robotic/timeoutcalled.wav");
	precache_sound ("announcer/robotic/1fragleft.wav");
	precache_sound ("announcer/robotic/1minuteremains.wav");
	precache_sound ("announcer/robotic/2fragsleft.wav");
	precache_sound ("announcer/robotic/3fragsleft.wav");
	if (g_minstagib)
	{
		precache_sound ("announcer/robotic/lastsecond.wav");
		precache_sound ("announcer/robotic/narrowly.wav");
	}

	precache_model ("models/sprites/1.spr32");
	precache_model ("models/sprites/2.spr32");
	precache_model ("models/sprites/3.spr32");
	precache_model ("models/sprites/4.spr32");
	precache_model ("models/sprites/5.spr32");
	precache_model ("models/sprites/6.spr32");
	precache_model ("models/sprites/7.spr32");
	precache_model ("models/sprites/8.spr32");
	precache_model ("models/sprites/9.spr32");
	precache_model ("models/sprites/10.spr32");
	precache_sound ("announcer/robotic/1.ogg");
	precache_sound ("announcer/robotic/2.ogg");
	precache_sound ("announcer/robotic/3.ogg");
	precache_sound ("announcer/robotic/4.ogg");
	precache_sound ("announcer/robotic/5.ogg");
	precache_sound ("announcer/robotic/6.ogg");
	precache_sound ("announcer/robotic/7.ogg");
	precache_sound ("announcer/robotic/8.ogg");
	precache_sound ("announcer/robotic/9.ogg");
	precache_sound ("announcer/robotic/10.ogg");

	// common weapon precaches
	precache_sound ("weapons/weapon_switch.wav");
	precache_sound ("weapons/weaponpickup.wav");
	if (cvar("g_grappling_hook"))
	{
		precache_sound ("weapons/hook_fire.wav"); // hook
		precache_sound ("weapons/hook_impact.wav"); // hook
	}

	if (cvar("sv_precacheweapons") || g_nixnex)
	{
		//precache weapon models/sounds
		local float wep;
		wep = WEP_FIRST;
		while (wep <= WEP_LAST)
		{
			weapon_action(wep, WR_PRECACHE);
			wep = wep + 1;
		}
	}

	// plays music for the level if there is any
	if (self.noise)
	{
		precache_sound (self.noise);
		ambientsound ('0 0 0', self.noise, VOL_BASE, ATTN_NONE);
	}
}

// sorry, but using \ in macros breaks line numbers
#define WRITESPECTATABLE_MSG_ONE_VARNAME(varname,statement) entity varname; varname = msg_entity; FOR_EACH_REALCLIENT(msg_entity) if(msg_entity == varname || (msg_entity.classname == STR_SPECTATOR && msg_entity.enemy == varname)) statement msg_entity = varname
#define WRITESPECTATABLE_MSG_ONE(statement) WRITESPECTATABLE_MSG_ONE_VARNAME(oldmsg_entity, statement)
#define WRITESPECTATABLE(msg,statement) if(msg == MSG_ONE) { WRITESPECTATABLE_MSG_ONE(statement); } else statement float WRITESPECTATABLE_workaround = 0

vector ExactTriggerHit_mins;
vector ExactTriggerHit_maxs;
float ExactTriggerHit_Recurse()
{
	float s;
	entity se;
	float f;

	tracebox('0 0 0', ExactTriggerHit_mins, ExactTriggerHit_maxs, '0 0 0', MOVE_NORMAL, other);
	if not(trace_ent)
		return 0;
	if(trace_ent == self)
		return 1;

	se = trace_ent;
	s = se.solid;
	se.solid = SOLID_NOT;
	f = ExactTriggerHit_Recurse();
	se.solid = s;

	return f;
}

float ExactTriggerHit()
{
	float f, s;

	if not(self.modelindex)
		return 1;

	s = self.solid;
	self.solid = SOLID_BSP;
	ExactTriggerHit_mins = other.absmin;
	ExactTriggerHit_maxs = other.absmax;
	f = ExactTriggerHit_Recurse();
	self.solid = s;

	return f;
}

// WARNING: this kills the trace globals
#define EXACTTRIGGER_TOUCH if not(ExactTriggerHit()) return
#define EXACTTRIGGER_INIT  InitSolidBSPTrigger(); self.solid = SOLID_TRIGGER

#define INITPRIO_FIRST              0
#define INITPRIO_GAMETYPE           0
#define INITPRIO_GAMETYPE_FALLBACK  1
#define INITPRIO_FINDTARGET        10
#define INITPRIO_SETLOCATION       90
#define INITPRIO_LINKDOORS         91
#define INITPRIO_LAST              99

.void(void) initialize_entity;
.float initialize_entity_order;
.entity initialize_entity_next;
entity initialize_entity_first;
void InitializeEntity(entity e, void(void) func, float order)
{
	entity prev, cur;

	if(!e || e.initialize_entity)
	{
		// make a proxy initializer entity
		entity e_old;
		e_old = e;
		e = spawn();
		e.classname = "initialize_entity";
		e.enemy = e_old;
	}

	e.initialize_entity = func;
	e.initialize_entity_order = order;

	cur = initialize_entity_first;
	for(;;)
	{
		if(!cur || cur.initialize_entity_order > order)
		{
			// insert between prev and cur
			if(prev)
				prev.initialize_entity_next = e;
			else
				initialize_entity_first = e;
			e.initialize_entity_next = cur;
			return;
		}
		prev = cur;
		cur = cur.initialize_entity_next;
	}
}
void InitializeEntitiesRun()
{
	for(self = initialize_entity_first; self; )
	{
		entity e;
		var void(void) func;
		e = self.initialize_entity_next;
		func = self.initialize_entity;
		self.initialize_entity_order = 0;
		self.initialize_entity = func_null;
		self.initialize_entity_next = world;
		if(self.classname == "initialize_entity")
		{
			entity e_old;
			e_old = self.enemy;
			remove(self);
			self = e_old;
		}
		dprint("Delayed initialization: ", self.classname, "\n");
		func();
		self = e;
	}
	initialize_entity_first = world;
}

.float nottargeted;
#define IFTARGETED if(!self.nottargeted && self.targetname != "")
