.entity pusher;
void TeleportPlayer(entity teleporter, entity player, vector to, vector to_angles, vector to_velocity)
{
	entity head;
	entity oldself;

	sound (player, CHAN_TRIGGER, "misc/teleport.wav", VOL_BASE, ATTN_NORM);
	pointparticles(particleeffectnum("teleport"), player.origin, '0 0 0', 1);

	makevectors (to_angles);
	pointparticles(particleeffectnum("teleport"), to + v_forward * 32, '0 0 0', 1);

	// Relocate the player
	// assuming to allows PL_MIN to PL_MAX box and some more
	setorigin (player, to + '0 0 1' * (1 - player.mins_z - 24));
	player.angles = to_angles;
	player.fixangle = TRUE;
	player.velocity = to_velocity;
	RemoveGrapplingHook(player);

	// Kill anyone else in the teleporter box (NO MORE TDEATH)
	if(player.takedamage && !g_race)
	{
		vector deathmin;
		vector deathmax;
		float deathradius;
		deathmin = player.absmin;
		deathmax = player.absmax;
		deathradius = max(vlen(deathmin), vlen(deathmax));
		for(head = findradius(player.origin, deathradius); head; head = head.chain)
			if(head != player)
				if(head.takedamage)
					if(boxesoverlap(deathmin, deathmax, head.absmin, head.absmax))
					{
						if ((player.classname == "player") && (player.health >= 1))
							Damage (head, teleporter, player, 10000, DEATH_TELEFRAG, head.origin, '0 0 0');
						else if (player.health < 1) // corpses gib
							Damage (head, teleporter, player, 10000, DEATH_TELEFRAG, head.origin, '0 0 0');
						else // dead bodies and monsters gib themselves instead of telefragging
							Damage (player, teleporter, player, 10000, DEATH_TELEFRAG, player.origin, '0 0 0');
					}
	}

	// hide myself a tic
	player.effects = player.effects | EF_NODRAW;
	if (player.weaponentity) // misuse FL_FLY to avoid EF_NODRAW on viewmodel
		player.weaponentity.flags = player.weaponentity.flags | FL_FLY;
	player.teleport_time = time + cvar("sys_ticrate");

	// player no longer is on ground
	player.flags = player.flags - (player.flags & FL_ONGROUND);

	// reset tracking of oldvelocity for impact damage (sudden velocity changes)
	player.oldvelocity = player.velocity;

	// reset tracking of who pushed you into a hazard (for kill credit)
	if(teleporter.owner)
	{
		player.pusher = teleporter.owner;
		player.pushltime = time + cvar("g_maxpushtime");
	}
	else
	{
		player.pushltime = 0;
	}

	// stop player name display
	{
		oldself = self;
		self = player;
		ClearSelectedPlayer();
		self = oldself;
	}
}

void Teleport_Touch (void)
{
	entity oldself;

	if (other.health < 1)
		return;
	if (!other.flags & FL_CLIENT)	// FIXME: Make missiles firable through the teleport too
		return;

	EXACTTRIGGER_TOUCH;

	makevectors(self.enemy.mangle);
	TeleportPlayer(self, other, self.enemy.origin + '0 0 1' * (1 - other.mins_z - 24), self.enemy.mangle, v_forward * vlen(other.velocity));

	if(self.enemy.target)
	{
		oldself = self;
		activator = other;
		self = self.enemy;
		SUB_UseTargets();
		self = oldself;
	}
}

void spawnfunc_info_teleport_destination (void)
{
	self.mangle = self.angles;
	self.angles = '0 0 0';

	//setorigin (self, self.origin + '0 0 27');	// To fix a mappers' habit as old as Quake
	setorigin (self, self.origin);

	IFTARGETED
	{
	}
	else
		objerror ("Teleport destination without a targetname");
}

void spawnfunc_misc_teleporter_dest (void)
{
	spawnfunc_info_teleport_destination();
}

void spawnfunc_target_teleporter (void)
{
	spawnfunc_info_teleport_destination();
}

void teleport_findtarget (void)
{
	// now enable touch
	self.touch = Teleport_Touch;

	self.enemy = find (world, targetname, self.target);
	if (!self.enemy)
	{
		objerror ("Teleporter with nonexistant target");
		remove(self);
		return;
	}

	self.dest = self.enemy.origin;
	waypoint_spawnforteleporter(self, self.dest, 0);
}

void spawnfunc_trigger_teleport (void)
{
	self.angles = '0 0 0';

	EXACTTRIGGER_INIT;

	// this must be called to spawn the teleport waypoints for bots
	InitializeEntity(self, teleport_findtarget, INITPRIO_FINDTARGET);

	if (!self.target)
		objerror ("Teleporter with no target");
}
